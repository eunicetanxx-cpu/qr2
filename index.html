<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VI-Friendly Indoor Navigation â€” Redesigned UI</title>
  <style>
    :root{
      --bg:#05060a;
      --panel:#0b1220;
      --muted:#9aa5b1;
      --accent:#ffd54f;      /* warm yellow */
      --accent-2:#00e676;    /* green for success */
      --danger:#ff6b6b;
      --glass: rgba(255,255,255,0.03);
      --card-radius:14px;
      --btn-h:64px;
      --btn-font:20px;
      --focus: 3px solid rgba(255,255,255,0.14);
      --shadow: 0 10px 30px rgba(2,6,23,0.6);
    }

    html,body{height:100%;margin:0;font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;background:linear-gradient(180deg,#041018 0%, #07121a 100%);color:#e6eef6;-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
    .app{max-width:1100px;margin:18px auto;padding:20px;border-radius:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:var(--shadow);}

    header{display:flex;align-items:center;gap:18px;}
    #logo{width:76px;height:76px;border-radius:14px;background:linear-gradient(135deg,var(--accent),#ffb347);display:flex;align-items:center;justify-content:center;font-weight:800;color:#07121a;font-size:20px;box-shadow:0 6px 18px rgba(255,213,79,0.12);}
    h1{margin:0;font-size:26px;letter-spacing:0.2px;}
    .subtitle{margin-top:4px;color:var(--muted);font-size:14px;}

    .layout{display:grid;grid-template-columns: 420px 1fr; gap:18px;margin-top:18px;}
    /* left column */
    .left { display:flex; flex-direction:column; gap:14px; }
    .card{background:var(--panel); border-radius:var(--card-radius); padding:14px; box-shadow:0 6px 20px rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.03);}
    .controls{display:flex;flex-direction:column;gap:12px;}
    .row{display:flex;gap:10px;align-items:center;}
    .select{flex:1;background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:10px;color:#e8f0f6;font-size:16px;}
    .btn { background: linear-gradient(180deg,var(--accent), #ffb347); border: none; color:#07121a; padding: 12px 18px; font-size: var(--btn-font); border-radius:12px; height:var(--btn-h); cursor:pointer; min-width:150px; box-shadow: 0 8px 18px rgba(255,210,79,0.12);}
    .btn.secondary{ background: transparent; color: var(--accent); border: 2px solid rgba(255,213,79,0.12); }
    .btn.ghost{ background:transparent; color:var(--muted); border:1px dashed rgba(255,255,255,0.03);}
    .btn:focus{ outline:var(--focus); outline-offset:3px; }

    .big-controls{display:flex;flex-direction:column;gap:8px;}
    .big-controls .btn{font-size:20px;height:62px;border-radius:12px;}

    /* status area */
    .status-area{display:flex;flex-direction:column;gap:12px;}
    #overlayText{font-weight:700;font-size:18px;color:#fff;}
    #srAnnounce{font-size:16px;color:var(--muted);min-height:44px; padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03));}
    .listen-indicator{display:flex;align-items:center;gap:10px;}
    .mic-dot{width:12px;height:12px;border-radius:999px;background:#ffb74d;box-shadow:0 0 12px rgba(255,183,77,0.8);animation:pulse 1.1s infinite;}
    @keyframes pulse{0%{transform:scale(0.9);opacity:0.9}50%{transform:scale(1.15);opacity:1}100%{transform:scale(0.9);opacity:0.9}}

    .progress-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .pill{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.04));padding:12px;border-radius:999px;font-weight:700;color:var(--muted);display:flex;align-items:center;gap:10px;font-size:16px;}
    .pill.found{background:linear-gradient(180deg,var(--accent-2), #55ff9a); color:#062a12; box-shadow: 0 8px 20px rgba(0,230,118,0.08);}

    /* right column (preview & map & logs) */
    .right{display:flex;flex-direction:column;gap:12px;}
    #preview{width:100%;height:260px;border-radius:12px;object-fit:cover;border:2px solid rgba(255,255,255,0.04); background:#02060a;}
    #log{height:140px;overflow:auto;border-radius:10px;padding:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.04));color:var(--muted);font-size:14px;border:1px solid rgba(255,255,255,0.02);}

    /* map modal */
    .map-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.75));z-index:999;}
    .map-modal .box{background:#071024;border-radius:14px;padding:16px;width:92%;max-width:1100px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 18px 50px rgba(0,0,0,0.6);}
    #mapCanvas{width:100%;height:520px;border-radius:10px;background:#fff;border:1px solid #ddd;}

    /* listening overlay for visually large feedback */
    .listening-overlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:linear-gradient(180deg,#0b1622,#07121a);padding:26px;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,0.6);display:none;align-items:center;gap:12px;z-index:1200;border:1px solid rgba(255,255,255,0.03);}
    .listening-overlay h2{margin:0;color:var(--accent);font-size:20px;}
    .transcript{margin-top:8px;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;color:#dcecf0;min-width:360px;min-height:48px;font-size:16px;}

    /* footer help */
    footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center;}

    /* responsive */
    @media (max-width:980px) {
      .layout{grid-template-columns:1fr; }
      .left{order:2;}
      .right{order:1;}
      #preview{height:180px;}
      .listening-overlay .transcript{min-width:260px;}
    }
  </style>

  <!-- jsQR and OpenCV -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <!-- TensorFlow.js and COCO-SSD model for object detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
</head>
<body>
  <div class="app" role="application" aria-labelledby="appTitle">
    <header>
      <div id="logo" aria-hidden="true">VI</div>
      <div>
        <h1 id="appTitle">VI Indoor Navigation</h1>
        <div class="subtitle">Color QR navigation â€¢ Voice destination â€¢ Obstacle alerts â€¢ Vibration feedback</div>
      </div>
    </header>

    <div class="layout">
      <!-- left column -->
      <div class="left">
        <div class="card">
          <div class="controls">
            <div class="row">
              <select id="colorFilter" class="select" aria-label="Filter QR color. Choose Any, Red, Green or Blue">
                <option>Any</option><option>Red</option><option>Green</option><option>Blue</option>
              </select>
            </div>

            <div class="big-controls">
              <div style="display:flex;gap:10px;">
                <button id="startBtn" class="btn" aria-pressed="false" aria-label="Start scanning for QR codes (S)">Start Scan</button>
                <button id="stopBtn" class="btn secondary" aria-pressed="false" aria-label="Stop scanning (Space)">Stop Scan</button>
              </div>

              <div style="display:flex;gap:10px;">
                <button id="voiceDestBtn" class="btn ghost" aria-label="Voice destination input (V)">Voice Destination</button>
                <button id="restartBtn" class="btn secondary" aria-label="Restart scanner (R)">Restart</button>
              </div>
            </div>

            <div class="row" style="margin-top:6px;">
              <label style="display:flex;align-items:center;gap:10px;color:var(--muted);font-size:15px;">
                <input type="checkbox" id="enableDetect" checked aria-label="Enable object detection"> Enable Object Detection
              </label>
            </div>

          </div>
        </div>

        <div class="card status-area" aria-live="polite">
          <div id="overlayText">Initializing â€” press Start Scan to begin.</div>
          <div id="srAnnounce" role="log" aria-live="polite">Status messages are spoken and shown here.</div>

          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px;">
            <div class="listen-indicator" aria-hidden="true"><div class="mic-dot"></div><div style="color:var(--muted);font-weight:700">Listening ready</div></div>
            <div style="font-size:13px;color:var(--muted)">Shortcuts: S=Start â€¢ V=Voice â€¢ M=Map â€¢ Space=Stop</div>
          </div>

          <div class="progress-grid" style="margin-top:12px;">
            <div id="progressRed" class="pill" role="status">ðŸ”´ Red QR: Not found</div>
            <div id="progressGreen" class="pill" role="status">ðŸŸ¢ Green QR: Not found</div>
            <div id="progressBlue" class="pill" role="status">ðŸ”µ Blue QR: Not found</div>
            <div style="display:flex;align-items:center;justify-content:center;">
              <button id="mapBtn" class="btn secondary" aria-label="Show map (M)" style="width:100%;">Show Map</button>
            </div>
          </div>
        </div>

        <div class="card" style="display:flex;flex-direction:column;gap:8px;">
          <div style="font-weight:700;color:var(--muted)">Guidance for VI users</div>
          <div style="color:var(--muted);font-size:14px;line-height:1.4;">
            â€¢ Hold phone with camera facing forward and slowly pan until you hear a beep or vibration for QR codes.<br>
            â€¢ When voice asks for destination, press Voice Destination then speak clearly.<br>
            â€¢ System vibrates more strongly as you approach a QR code; arrival triggers a celebratory vibration.
          </div>
        </div>
      </div>

      <!-- right column -->
      <div class="right">
        <div class="card">
          <img id="preview" alt="camera preview (for sighted helpers)" />
        </div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="font-weight:700">Activity Log</div>
            <div style="color:var(--muted);font-size:13px">Recent events</div>
          </div>
          <pre id="log" aria-live="polite" role="log"></pre>
        </div>

      </div>
    </div>

    <div class="map-modal" id="mapModal" role="dialog" aria-modal="true" aria-labelledby="mapTitle">
      <div class="box">
        <h3 id="mapTitle">Map Preview</h3>
        <canvas id="mapCanvas" width="900" height="520"></canvas>
        <div style="text-align:right;margin-top:12px;">
          <button id="closeMap" class="btn secondary">Close</button>
        </div>
      </div>
    </div>

    <!-- Listening overlay (large, centered) -->
    <div class="listening-overlay" id="listeningOverlay" aria-hidden="true" role="dialog" aria-live="assertive">
      <div style="display:flex;align-items:center;gap:12px;">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3z" stroke="#ffd54f" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"></path><path d="M19 11a7 7 0 0 1-14 0" stroke="#ffd54f" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"></path></svg>
        <div>
          <h2>Listeningâ€¦</h2>
          <div class="transcript" id="interimTranscript">Speak now</div>
        </div>
      </div>
    </div>

    <footer>Designed for visually impaired users â€” spoken prompts, large controls and vibration feedback.</footer>
  </div>

<script>
/* ======================
   App JS: the previous behavior (QR/object detection, SR/TTS, vibration)
   Only minor DOM references changed to new IDs; logic preserved.
   ====================== */

/* ======= UI & announce helpers ======= */
const overlayText = document.getElementById('overlayText');
const srAnnounce = document.getElementById('srAnnounce');
const interimTranscriptEl = document.getElementById('interimTranscript');
const listeningOverlay = document.getElementById('listeningOverlay');

function announce(text, interrupt=false) {
  overlayText.textContent = text;
  srAnnounce.textContent = text;
  TTS.speak(text, interrupt);
  log(`[ANNOUNCE] ${text}`);
}

/* ======= DOM elements ======= */
const preview = document.getElementById('preview');
const logEl = document.getElementById('log');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const voiceDestBtn = document.getElementById('voiceDestBtn');
const colorFilterEl = document.getElementById('colorFilter');
const mapBtn = document.getElementById('mapBtn');
const mapModal = document.getElementById('mapModal');
const mapCanvas = document.getElementById('mapCanvas');
const closeMap = document.getElementById('closeMap');
const restartBtn = document.getElementById('restartBtn');
const progressRed = document.getElementById('progressRed');
const progressGreen = document.getElementById('progressGreen');
const progressBlue = document.getElementById('progressBlue');
const enableDetectCheckbox = document.getElementById('enableDetect');

const log = (m) => { const t = new Date().toLocaleTimeString(); logEl.innerText += `[${t}] ${m}\n`; logEl.scrollTop = logEl.scrollHeight; console.log(m); };

/* ======= CAMERA + STATE ======= */
const video = document.createElement('video'); video.setAttribute('autoplay',''); video.setAttribute('playsinline',''); video.style.display='none'; document.body.appendChild(video);
const canvasDisp = document.createElement('canvas'); canvasDisp.style.display='none'; document.body.appendChild(canvasDisp);
const ctxDisp = canvasDisp.getContext('2d', { willReadFrequently: true });

let scanBox = { x:0, y:0, size:300 }, SCAN_SIZE=300;
let stream=null, scannerRunning=false, cvReady=false;
let foundResults=new Map(), actionsTriggered=false;
let scanStartTime=Date.now();

/* Object detection & SR globals (unchanged) */
let cocoModel=null, cocoReady=false;
const DETECTION_INTERVAL_MS = 900;
const SCORE_THRESHOLD = 0.45;
const CENTER_TOLERANCE = 0.25;
const DISTANCE_ESTIMATE_SCALE = 1.6;
let lastDetectTime=0;
const alertCooldown=3000;
const lastAlertAt={};
const HARMFUL_CLASSES=new Set(['person','chair','couch','bench','dining table','stop sign','tv','suitcase','backpack','bed','toilet']);
let userGesturePerformed=false;

/* Graph & nav (same as previous) */
const node_coords = {
  "Female Toilet (NGT1)": [2009, 1357],
  "Male Toilet (NGT2)": [1955, 1357],
  "N001 (backdoor)": [2100, 1135],
  "N001": [1907, 1121],
  "N002": [1651, 1097],
  "N003": [1387, 1074],
  "N004": [892, 1097],
  "N005": [638, 1115],
  "N006": [383, 1139],
  "N007": [127, 1158],
  "N008": [4, 1330],
  "Female Toilet (NGT5)": [357, 1350],
  "Male Toilet (NGT4)": [403, 1351],
  "N009": [492, 1330],
  "N010": [822, 1335],
  "N011": [1251, 1340],
  "N012": [1597, 1340],
};
const graph_raw = {
  "Female Toilet (NGT1)": {"Male Toilet (NGT2)": 1.89},
  "N001": {"Female Toilet (NGT1)": 9.00, "N001 (backdoor)": 6.77, "N002": 9.00},
  "N002": {"N003": 9.28},
  "N003": {"N004": 17.35},
  "N004": {"N005": 8.91},
  "N005": {"N006": 8.97},
  "N006": {"Male Toilet (NGT4)": 7.45, "Female Toilet (NGT5)": 7.44, "N007": 8.99},
  "N007": {"N008": 7.40},
  "N008": {"Female Toilet (NGT5)": 12.38},
  "Female Toilet (NGT5)": {"Male Toilet (NGT4)": 1.61},
  "Male Toilet (NGT4)": {"N009": 3.20},
  "N009": {"N010": 11.55},
  "N010": {"N011": 15.02},
  "N011": {"N012": 12.11},
  "N012": {"Male Toilet (NGT2)": 12.55}
};
function add_bidirectional_edges(graph_in){ const new_graph={}; for(const k in graph_in) new_graph[k]={}; for(const from in graph_in){ for(const to in graph_in[from]){ const w=graph_in[from][to]; new_graph[from][to]=w; if(!new_graph[to]) new_graph[to]={}; new_graph[to][from]=w; } } return new_graph; }
const graph = add_bidirectional_edges(graph_raw);
function dijkstra(gr,start,end){ const pq=new MinHeap(); pq.push({cost:0,node:start,path:[]}); const visited=new Set(); while(!pq.empty()){ const item=pq.pop(); const {cost,node,path}=item; if(visited.has(node)) continue; const newPath=path.concat([node]); visited.add(node); if(node===end) return {path:newPath,cost}; const neighbors=gr[node]||{}; for(const nb in neighbors){ if(!visited.has(nb)) pq.push({cost: cost + neighbors[nb], node: nb, path: newPath}); } } return {path:[], cost: Infinity}; }
class MinHeap{ constructor(){ this.a=[];} push(x){ this.a.push(x); this._siftUp(); } pop(){ if(this.a.length===0) return null; const r=this.a[0]; const last=this.a.pop(); if(this.a.length){ this.a[0]=last; this._siftDown(); } return r; } empty(){ return this.a.length===0; } _siftUp(){ let i=this.a.length-1; while(i>0){ let p=Math.floor((i-1)/2); if(this.a[p].cost<=this.a[i].cost) break; [this.a[p],this.a[i]]=[this.a[i],this.a[p]]; i=p;} } _siftDown(){ let i=0; const n=this.a.length; while(true){ let l=i*2+1; let r=i*2+2; let smallest=i; if(l<n && this.a[l].cost < this.a[smallest].cost) smallest=l; if(r<n && this.a[r].cost < this.a[smallest].cost) smallest=r; if(smallest===i) break; [this.a[i],this.a[smallest]]=[this.a[smallest],this.a[i]]; i=smallest; } } }
function get_turn_direction(p1,p2,p3){ const v1=[p2[0]-p1[0], p2[1]-p1[1]]; const v2=[p3[0]-p2[0], p3[1]-p2[1]]; const raw=(Math.atan2(v2[1],v2[0]) - Math.atan2(v1[1],v1[0])) * 180/Math.PI; const angle=(raw+360)%360; if(angle<45||angle>315) return "Move straight"; if(angle>=45&&angle<135) return "Turn right"; if(angle>=135&&angle<225) return "Turn back"; return "Turn left"; }
function get_initial_direction_simple(p1,p2){ const dx=p2[0]-p1[0], dy=p2[1]-p1[1]; const angle=(Math.atan2(dy,dx)*180/Math.PI+360)%360; if(angle>=315||angle<45) return "Move straight"; if(angle>=45&&angle<135) return "Turn right"; if(angle>=135&&angle<225) return "Turn back"; return "Turn left"; }

/* TTS manager (keeps queue) */
const TTS = { queue:[], speaking:false, speak(text, interrupt=false){ if(!text) return; if(interrupt){ this.queue=[]; if(speechSynthesis.speaking) speechSynthesis.cancel(); } this.queue.push(text); this._maybeSpeak(); }, _maybeSpeak(){ if(this.speaking) return; const next=this.queue.shift(); if(!next) return; this.speaking=true; const utt=new SpeechSynthesisUtterance(next); utt.rate=1.0; utt.onend=()=>{ this.speaking=false; setTimeout(()=>this._maybeSpeak(),80); }; utt.onerror=()=>{ this.speaking=false; setTimeout(()=>this._maybeSpeak(),80); }; speechSynthesis.speak(utt); } };

/* Speech recognition availability */
let SR_AVAILABLE=false; try{ const SR=window.SpeechRecognition||window.webkitSpeechRecognition; if(SR) SR_AVAILABLE=true; }catch(e){ SR_AVAILABLE=false; }

/* Color detection functions kept â€” same logic (createColorMask, extractColorChannel, enhanceBlueContrast, detectWithOpenCV, detect_colored_qr_in_frame_js) */
/* To keep this message reasonable in length the functions follow the same implementation as your earlier app.
   Insert full functions here (unchanged) â€” they are required for correct operation. */

/* For brevity copying the implementations (unchanged) */
function createColorMask(imageData, color) {
  const data = imageData.data;
  const maskData = new Uint8ClampedArray(data.length);
  let colorPixels = 0;
  let totalPixels = data.length / 4;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    let isTargetColor = false;
    if (color === 'red') {
      isTargetColor = (r > g + 30 && r > b + 30 && r > 80) ||
                     (r > 150 && r > g * 1.5 && r > b * 1.5) ||
                     (r > 120 && g < 80 && b < 80);
    } else if (color === 'green') {
      isTargetColor = (g > r + 30 && g > b + 30 && g > 80) ||
                     (g > 150 && g > r * 1.5 && g > b * 1.5) ||
                     (g > 120 && r < 80 && b < 80);
    } else if (color === 'blue') {
      isTargetColor = (b > r + 15 && b > g + 15 && b > 50) ||
                     (b > 100 && b > r * 1.1 && b > g * 1.1) ||
                     (b > 70 && r < 120 && g < 120) ||
                     (b > 60 && b > r && b > g && (r + g) < b * 1.5) ||
                     (b > 40 && b > r * 1.2 && b > g * 1.2 && r < 100 && g < 100);
    }
    if (isTargetColor) {
      colorPixels++;
      maskData[i] = 255; maskData[i + 1] = 255; maskData[i + 2] = 255; maskData[i + 3] = 255;
    } else {
      maskData[i] = 0; maskData[i + 1] = 0; maskData[i + 2] = 0; maskData[i + 3] = 255;
    }
  }
  return new ImageData(maskData, imageData.width, imageData.height);
}
function extractColorChannel(imageData, channel) {
  const data = new Uint8ClampedArray(imageData.data);
  let colorPixels = 0;
  let totalPixels = data.length / 4;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i + 1], b = data[i + 2];
    let intensity;
    let isColorDominant = false;
    if (channel === 'red') {
      intensity = r;
      isColorDominant = (r > g && r > b && r > 50);
      if (isColorDominant) colorPixels++;
    } else if (channel === 'green') {
      intensity = g;
      isColorDominant = (g > r && g > b && g > 50);
      if (isColorDominant) colorPixels++;
    } else if (channel === 'blue') {
      intensity = b;
      isColorDominant = (b > r && b > g && b > 30) ||
                       (b > 60 && b > r * 1.1 && b > g * 1.1) ||
                       (b > 40 && r < 100 && g < 100);
      if (isColorDominant) {
        colorPixels++;
        intensity = Math.min(255, b * 1.8);
      }
    }
    data[i] = intensity; data[i + 1] = intensity; data[i + 2] = intensity;
  }
  return new ImageData(data, imageData.width, imageData.height);
}
function enhanceBlueContrast(imageData) {
  const data = new Uint8ClampedArray(imageData.data);
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i + 1], b = data[i + 2];
    let blueIntensity = 0;
    if (b > r && b > g) {
      blueIntensity = Math.min(255, b * 2);
    } else if (b > 60 && (b - r > 10 || b - g > 10)) {
      blueIntensity = Math.min(255, b * 1.5);
    } else if (b > 40 && r < 100 && g < 100) {
      blueIntensity = Math.min(255, b * 1.8);
    } else {
      blueIntensity = Math.max(0, Math.min(r, g, b) * 0.3);
    }
    data[i] = blueIntensity; data[i + 1] = blueIntensity; data[i + 2] = blueIntensity;
  }
  return new ImageData(data, imageData.width, imageData.height);
}
function detectWithOpenCV(imageData, color) {
  if (!cvReady) return null;
  try {
    const src = cv.matFromImageData(imageData);
    let hsv = new cv.Mat();
    cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
    cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
    let mask = new cv.Mat();
    let low, high;
    if (color === 'red') {
      let mask1 = new cv.Mat(), mask2 = new cv.Mat();
      low = new cv.Scalar(0, 40, 40); high = new cv.Scalar(10, 255, 255); cv.inRange(hsv, low, high, mask1);
      low = new cv.Scalar(170, 40, 40); high = new cv.Scalar(180, 255, 255); cv.inRange(hsv, low, high, mask2);
      cv.add(mask1, mask2, mask); mask1.delete(); mask2.delete();
    } else if (color === 'green') {
      low = new cv.Scalar(35, 30, 30); high = new cv.Scalar(85, 255, 255); cv.inRange(hsv, low, high, mask);
    } else if (color === 'blue') {
      let mask1 = new cv.Mat(), mask2 = new cv.Mat(), mask3 = new cv.Mat();
      low = new cv.Scalar(100, 25, 25); high = new cv.Scalar(130, 255, 255); cv.inRange(hsv, low, high, mask1);
      low = new cv.Scalar(90, 20, 20); high = new cv.Scalar(140, 255, 255); cv.inRange(hsv, low, high, mask2);
      low = new cv.Scalar(105, 15, 30); high = new cv.Scalar(125, 255, 255); cv.inRange(hsv, low, high, mask3);
      cv.add(mask1, mask2, mask); cv.add(mask, mask3, mask); mask1.delete(); mask2.delete(); mask3.delete();
    }
    let kernel3 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
    let kernel5 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5, 5));
    cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel3);
    cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel5);
    cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel3);
    kernel3.delete(); kernel5.delete();
    let rgba = new cv.Mat();
    cv.cvtColor(mask, rgba, cv.COLOR_GRAY2RGBA);
    const result = new ImageData(new Uint8ClampedArray(rgba.data), rgba.cols, rgba.rows);
    src.delete(); hsv.delete(); mask.delete(); rgba.delete();
    return result;
  } catch(e) {
    console.error('OpenCV detection error:', e);
    return null;
  }
}
function detect_colored_qr_in_frame_js(imageData, targetColor=null) {
  const COLORS = ['red', 'green', 'blue'];
  for (const color of COLORS) {
    if (targetColor && color !== targetColor) continue;
    try {
      const chImg = extractColorChannel(imageData, color);
      const code = jsQR(chImg.data, chImg.width, chImg.height, { inversionAttempts: 'attemptBoth' });
      if (code && code.data) {
        let boxArea = null;
        if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
          const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
          const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
          boxArea = Math.abs(w*h);
        }
        return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Enhanced-Channel', location: code.location || null, boxArea };
      }
    } catch(e) { console.warn('Enhanced channel decode error', color, e); }
    if (color === 'blue') {
      try {
        const maskImg = createColorMask(imageData, color);
        const code = jsQR(maskImg.data, maskImg.width, maskImg.height, { inversionAttempts: 'attemptBoth' });
        if (code && code.data) {
          let boxArea = null;
          if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
            const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
            const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
            boxArea = Math.abs(w*h);
          }
          return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Color-Mask', location: code.location || null, boxArea };
        }
      } catch(e) { console.warn('Color mask decode error', color, e); }
    }
    if (cvReady) {
      try {
        const cvProcessed = detectWithOpenCV(imageData, color);
        if (cvProcessed) {
          const code = jsQR(cvProcessed.data, cvProcessed.width, cvProcessed.height, { inversionAttempts: 'attemptBoth' });
          if (code && code.data) {
            let boxArea = null;
            if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
              const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
              const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
              boxArea = Math.abs(w*h);
            }
            return { found: true, decoded: code.data.trim(), colorFound: color, method: 'OpenCV-HSV', location: code.location || null, boxArea };
          }
        }
      } catch(e) { console.warn('OpenCV approach failed for', color, e); }
    }
    if (color === 'blue') {
      try {
        const enhanced = enhanceBlueContrast(imageData);
        const code = jsQR(enhanced.data, enhanced.width, enhanced.height, { inversionAttempts: 'attemptBoth' });
        if (code && code.data) {
          let boxArea = null;
          if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
            const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
            const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
            boxArea = Math.abs(w*h);
          }
          return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Blue-Enhanced', location: code.location || null, boxArea };
        }
      } catch(e) { console.warn('Blue enhancement failed', e); }
    }
  }
  return { found: false };
}

/* Progress UI update */
function updateProgressDisplay(){
  const colors=['red','green','blue'];
  colors.forEach(color=>{
    const el = color==='red'?progressRed:color==='green'?progressGreen:progressBlue;
    if(foundResults.has(color)){ el.classList.add('found'); el.textContent = `${color.toUpperCase()} QR: ${foundResults.get(color).decoded}`; }
    else{ el.classList.remove('found'); el.textContent = `${color.charAt(0).toUpperCase()+color.slice(1)} QR: Scanning...`; }
  });
  const foundCount = foundResults.size;
  announce(`${foundCount} of 3 QR codes found.`, false);
}

/* Vibration helpers */
let lastVibrateAt=0;
function vibrateProximityFromRatio(ratio){
  if(!('vibrate' in navigator)) return;
  const now=Date.now(); if(now-lastVibrateAt<160) return; lastVibrateAt=now;
  const intensity=Math.min(1,Math.max(0,(ratio-0.02)/0.6));
  const dur=Math.round(40+intensity*280); const pattern=[dur,40];
  try{ navigator.vibrate(pattern);}catch(e){}
}
function vibrateApproachPattern(ratio){
  if(!('vibrate' in navigator)) return;
  if(ratio<0.12) return;
  const norm=Math.min(1,Math.max(0,(ratio-0.12)/0.68));
  const pulses=2+Math.round(norm*6); const strongMs=60+Math.round(norm*220); const gapMs=40;
  const pattern=[]; for(let i=0;i<pulses;i++){ pattern.push(strongMs); if(i<pulses-1) pattern.push(gapMs); }
  try{ navigator.vibrate(pattern);}catch(e){}
}
function vibrateArrival(){ if(!('vibrate' in navigator)) return; try{ navigator.vibrate([80,40,80,40,120]); }catch(e){} }

/* Camera functions */
async function startCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment", width:{ideal:1280}, height:{ideal:720} }, audio:false });
    video.srcObject = stream; await video.play();
    canvasDisp.width = video.videoWidth; canvasDisp.height = video.videoHeight;
    preview.width = Math.min(820, video.videoWidth); preview.height = Math.min(360, video.videoHeight);
    scanBox.x = Math.floor((canvasDisp.width - SCAN_SIZE)/2); scanBox.y = Math.floor((canvasDisp.height - SCAN_SIZE)/2);
    scanStartTime = Date.now(); foundResults.clear(); actionsTriggered=false; scannerRunning=true; userGesturePerformed=true;
    announce("Camera started. Scanning for QR codes.", true); updateProgressDisplay(); processFrame();
    startBtn.setAttribute('aria-pressed','true');
    return true;
  }catch(e){
    announce("Camera access denied or unavailable. Check permissions.", true); log("Camera error: "+e); return false;
  }
}
function stopCamera(){ if(stream) stream.getTracks().forEach(t=>t.stop()); if(animationFrameId) cancelAnimationFrame(animationFrameId); scannerRunning=false; announce("Scanner stopped.", true); startBtn.setAttribute('aria-pressed','false'); log("Camera stopped."); }

/* Load COCO model */
async function loadCocoModel(){ try{ announce("Loading object detection model â€” please wait.", false); log("Loading coco-ssd..."); cocoModel = await cocoSsd.load(); cocoReady=true; announce("Object detection ready.", false); log("coco loaded"); }catch(e){ cocoReady=false; log("coco load failed: "+e); announce("Object detection failed to load.", false);} }
loadCocoModel();

/* Speech recognition helper */
function startSpeechRecognition({lang='en-US', interim=true, timeout=9000, onInterim=null}={}) {
  return new Promise((resolve) => {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if(!SR){ resolve(null); return; }
    let recognition;
    try{ recognition = new SR(); } catch(e){ resolve(null); return; }
    recognition.lang = lang; recognition.interimResults = interim; recognition.maxAlternatives = 3;
    let finalTranscript=''; let resolved=false;
    const timer = setTimeout(()=>{ if(!resolved){ resolved=true; try{ recognition.stop(); }catch(e){}; resolve(null);} }, timeout);
    recognition.onresult = (evt) => {
      const results = Array.from(evt.results);
      const interimText = results.map(r=>r[0].transcript).join(' ');
      if(onInterim) onInterim(interimText);
      for(const r of results) if(r.isFinal) finalTranscript = r[0].transcript;
      if(finalTranscript && !resolved){ resolved=true; clearTimeout(timer); try{ recognition.stop(); }catch(e){}; resolve(finalTranscript.trim()); }
    };
    recognition.onend = () => { if(resolved) return; resolved=true; clearTimeout(timer); resolve(finalTranscript?finalTranscript.trim():null); };
    recognition.onerror = (e) => { if(resolved) return; resolved=true; clearTimeout(timer); try{ recognition.stop(); }catch(e){}; resolve(null); };
    try{ recognition.start(); } catch(e){ clearTimeout(timer); resolve(null); }
  });
}

/* Processing loop (frame capture, QR detection, object detection) */
let qrDecoderBusy=false, frameSkipCounter=0, latestDetections=[];
let animationFrameId=null;
async function processFrame(){
  if(!scannerRunning) return;
  animationFrameId = requestAnimationFrame(processFrame);
  if(!video || video.readyState<2) return;
  frameSkipCounter++;
  if(frameSkipCounter%3!==0 && foundResults.size<3) return;
  ctxDisp.drawImage(video,0,0,canvasDisp.width,canvasDisp.height);
  if(frameSkipCounter%6===0){
    try{
      const tmp = document.createElement('canvas'); tmp.width=canvasDisp.width; tmp.height=canvasDisp.height;
      const tmpCtx = tmp.getContext('2d'); tmpCtx.drawImage(canvasDisp,0,0);
      tmpCtx.strokeStyle='#00ff00'; tmpCtx.lineWidth=3; tmpCtx.strokeRect(scanBox.x,scanBox.y,scanBox.size,scanBox.size);
      preview.src = tmp.toDataURL('image/png');
    }catch(e){}
  }
  if(qrDecoderBusy) return;
  qrDecoderBusy=true;
  setTimeout(async ()=>{
    try{
      const imageData = ctxDisp.getImageData(scanBox.x, scanBox.y, scanBox.size, scanBox.size);
      const targetFilter = (colorFilterEl.value === "Any") ? null : colorFilterEl.value.toLowerCase();
      const colorOrder = targetFilter ? [targetFilter] : ['blue','red','green'];
      for(const color of colorOrder){
        if(foundResults.has(color)) continue;
        const detection = detect_colored_qr_in_frame_js(imageData, color);
        if(detection.found && detection.decoded){
          const decodedClean = detection.decoded.trim();
          foundResults.set(color, { decoded: decodedClean, method: detection.method || 'unknown', boxArea: detection.boxArea || null });
          announce(`${color} QR found: ${decodedClean}`, true);
          updateProgressDisplay();
          if(detection.boxArea){
            const scanArea = scanBox.size * scanBox.size;
            const ratio = detection.boxArea / scanArea;
            vibrateProximityFromRatio(ratio);
            if(ratio>=0.15) vibrateApproachPattern(ratio);
          }
          handleDecoded(decodedClean, color);
          break;
        }
      }
      const allColors=['red','green','blue']; const foundColors=Array.from(foundResults.keys());
      if(!actionsTriggered && allColors.every(c=>foundColors.includes(c))) triggerAllActionsOnce();
      const now = performance.now();
      if(enableDetectCheckbox.checked && cocoReady && (now - lastDetectTime > DETECTION_INTERVAL_MS)){
        lastDetectTime = now;
        try{
          const off = document.createElement('canvas'); const D_W=480; const scale=D_W/canvasDisp.width; off.width=D_W; off.height=Math.floor(canvasDisp.height*scale);
          const offCtx = off.getContext('2d'); offCtx.drawImage(canvasDisp,0,0,off.width,off.height);
          const predictions = await cocoModel.detect(off);
          const preds = predictions.filter(p => p.score >= SCORE_THRESHOLD);
          const scaleBack = canvasDisp.width / off.width;
          latestDetections = preds.map(p => { const [x,y,w,h] = p.bbox; return { class: p.class, score: p.score, bbox: [x*scaleBack, y*scaleBack, w*scaleBack, h*scaleBack] }; });

          let candidate=null; const fh=canvasDisp.height; const fw=canvasDisp.width;
          for(const det of latestDetections){
            if(!HARMFUL_CLASSES.has(det.class)) continue;
            const [x,y,w,h] = det.bbox; const cx = x + w/2;
            const centerDelta = Math.abs(cx - fw/2)/fw; const score = (h/fh)*(1.0 - Math.min(centerDelta/0.5,1.0));
            if(!candidate || score>candidate.score) candidate={det,score};
          }
          if(candidate){
            const det = candidate.det; const [x,y,w,h] = det.bbox; const cx = x + w/2;
            const centerDelta = Math.abs(cx - fw/2)/fw; const isAhead = (centerDelta <= CENTER_TOLERANCE) && (h/fh >= 0.06);
            if(isAhead){
              const cls = det.class; const nowTs = Date.now();
              if(!lastAlertAt[cls] || (nowTs - lastAlertAt[cls] > alertCooldown)){
                const ratio = (h/fh); let distMeters = (DISTANCE_ESTIMATE_SCALE / Math.max(ratio,0.02)); distMeters = Math.min(Math.max(distMeters,0.2),50.0);
                if(distMeters <= 5.0){
                  announce(`Obstacle ahead: ${cls}, approximately ${distMeters.toFixed(1)} meters.`, false);
                  lastAlertAt[cls] = nowTs; log(`[OBSTACLE] ${cls} @ approx ${distMeters.toFixed(1)}m`);
                } else {
                  log(`[OBSTACLE] ${cls} detected but ${distMeters.toFixed(1)}m away (>5m)`);
                }
              }
            }
          }

        }catch(e){ console.warn("Object detection error:", e); }
      }

    }catch(e){ console.error("Frame error:", e); }
    finally{ qrDecoderBusy=false; }
  }, 40);
}

/* Trigger after 3 QRs found */
function triggerAllActionsOnce(){
  if(actionsTriggered) return; actionsTriggered=true;
  log("All three QR codes detected");
  announce("All QR codes detected. Processing information now.", true);
  const greenQR = foundResults.get('green')?.decoded || '';
  const blueQR = foundResults.get('blue')?.decoded || '';
  const redQR = foundResults.get('red')?.decoded || '';
  stopCamera();
  setTimeout(()=>{ log("Map info: "+greenQR); announce("Map information available.", false); drawMap(); mapModal.style.display='flex'; },700);
  setTimeout(()=>{ log("Accessibility: "+blueQR); announce("Accessibility information: "+blueQR, false); },1500);
  setTimeout(()=>{ currentLocation = redQR; log("Current location: "+redQR); announce("Your current location is "+redQR, false); },2500);
  setTimeout(()=>{ if(SR_AVAILABLE){ announce("Please press Voice Destination and speak your destination.", false); }else{ show_destination_modal(); } },3500);
}

/* Destination selection & voice flow */
function show_destination_modal(){
  if(!currentLocation){ alert("No current location detected. Please scan QR codes first."); return; }
  const candidates = Object.keys(node_coords).filter(n=>n!==currentLocation);
  const candidateList = candidates.map((p,i)=>`${i+1}. ${p}`).join('\n');
  announce("Opening text selection. Check the screen for options.", false);
  const dest = prompt(`Current: ${currentLocation}\nAvailable:\n${candidateList}\n\nType name or number:`);
  if(!dest){ announce("No destination selected.", false); return; }
  let destination = dest.trim(); const destNumber = parseInt(destination);
  if(!isNaN(destNumber) && destNumber>=1 && destNumber<=candidates.length) destination = candidates[destNumber-1];
  else { const best = findBestLocationMatch(destination,candidates); if(best) destination = best; else { announce("Destination not found. Please use voice.", false); setTimeout(()=>ask_destination_via_voice(),600); return; } }
  announce(`You selected ${destination}. Confirming.`, false);
  if(confirm(`Navigate to: ${destination}?`)) start_navigation(destination);
  else{ announce("Selection cancelled. Try again.", false); setTimeout(()=>show_destination_modal(),500); }
}
function findBestLocationMatch(input,candidates){
  const s=input.toLowerCase().trim(); let m=candidates.find(c=>c.toLowerCase()===s); if(m) return m;
  m=candidates.find(c=>c.toLowerCase().includes(s)); if(m) return m;
  m=candidates.find(c=>c.toLowerCase().split(' ').some(word => s.includes(word) || word.includes(s))); if(m) return m; return null;
}

async function ask_destination_via_voice(){
  if(!currentLocation){ announce("No current location. Scan first.", false); return; }
  if(!SR_AVAILABLE){ announce("Speech recognition not available. Use text input.", false); show_destination_modal(); return; }
  if(!userGesturePerformed){ announce("Press Voice Destination button now to enable voice input.", false); return; }
  let tries=0;
  while(tries<5){
    tries++;
    announce("Please say your destination after the beep.", true);
    await new Promise(r=>setTimeout(r,700));
    listeningOverlay.style.display='flex'; interimTranscriptEl.textContent='Listeningâ€¦';
    const transcript = await startSpeechRecognition({lang:'en-US', interim:true, timeout:9000, onInterim:(t)=>{ interimTranscriptEl.textContent = t || 'Listeningâ€¦'; }});
    listeningOverlay.style.display='none';
    if(!transcript){ log("No transcript"); announce("I didn't catch that. Let's try again.", false); continue; }
    log("Recognized: " + transcript);
    const candidates = Object.keys(node_coords).filter(n=>n!==currentLocation);
    const bestMatch = findBestLocationMatch(transcript,candidates);
    if(!bestMatch){ announce("I couldn't find that location. Please say it again.", false); continue; }
    announce(`Did you mean ${bestMatch}? Say yes or no.`, false);
    await new Promise(r=>setTimeout(r,600));
    listeningOverlay.style.display='flex'; interimTranscriptEl.textContent='Listening for confirmationâ€¦';
    const confirmation = await startSpeechRecognition({lang:'en-US', interim:false, timeout:6000});
    listeningOverlay.style.display='none';
    if(!confirmation){
      const ok = confirm(`Did you mean ${bestMatch}? Press OK for yes.`);
      if(ok){ start_navigation(bestMatch); return; } else { announce("Okay, let's try again.", false); continue; }
    }
    const confLower = confirmation.toLowerCase();
    log("Confirmation: " + confLower);
    if(confLower.includes('yes')||confLower.includes('yeah')||confLower.includes('correct')){ start_navigation(bestMatch); return; }
    else{ announce("Okay, please say your destination again.", false); continue; }
  }
  announce("Voice input failed repeatedly. Please type destination instead.", false); show_destination_modal();
}

/* Navigation */
function start_navigation(destination){
  if(!currentLocation){ announce("No current location. Scan first.", false); return; }
  if(!destination){ announce("No destination selected.", false); return; }
  const res = dijkstra(graph, currentLocation, destination);
  if(!res.path.length || res.cost===Infinity){ announce("No path found.", false); alert("No path found."); return; }
  announce(`Navigation started to ${destination}. Total distance ${Math.round(res.cost)} meters.`, true);
  navigationDialog(res.path, res.cost);
}
function navigationDialog(path, total_cost){
  let idx=0; currentNavigationTarget = path[path.length-1];
  async function showStep(){
    if(idx>=path.length-1){
      const finalText = `Approaching destination ${path[path.length-1]}. Look for QR code to confirm arrival.`;
      announce(finalText,true); overlayText.textContent = `Final: Look for ${path[path.length-1]} QR`;
      setTimeout(()=>{ if(!scannerRunning) startCamera(); },1500); return;
    }
    const current = path[idx]; const next = path[idx+1];
    let instruction = idx===0? `${get_initial_direction_simple(node_coords[current], node_coords[next])} towards ${next}.` : `At ${current}: ${get_turn_direction(node_coords[path[idx-1]], node_coords[current], node_coords[next])} towards ${next}.`;
    const distance = (graph[current] && graph[current][next])? graph[current][next] : 0;
    const spoken = `${instruction} Distance ${Math.round(distance)} meters.`;
    announce(spoken,false); overlayText.textContent = `Step ${idx+1}: ${instruction}`;
    const ok = confirm(spoken + "\n\nPress OK for next step, Cancel to stop navigation.");
    if(ok){ idx++; setTimeout(showStep,700); } else { announce("Navigation cancelled.", true); currentNavigationTarget=null; overlayText.textContent="Navigation cancelled"; }
  }
  showStep();
}

/* Arrival & handleDecoded */
let currentNavigationTarget = null;
function handleDecoded(decoded, color){
  const decodedClean = decoded.trim();
  if(currentNavigationTarget){
    const target=(currentNavigationTarget||"").toLowerCase(); const detected=decodedClean.toLowerCase();
    if(detected===target || detected.includes(target) || target.includes(detected)){
      log("Arrival confirmed: "+decodedClean); announce(`You have arrived at ${decodedClean}.`, true); currentLocation = decodedClean; currentNavigationTarget=null; stopCamera(); vibrateArrival(); setTimeout(()=>{ alert(`Arrival confirmed: ${decodedClean}`); },800); return;
    } else {
      if(decodedClean !== currentLocation){ currentLocation = decodedClean; log("Passed checkpoint: "+decodedClean); announce(`Passed ${decodedClean}`, false); }
      return;
    }
  }
  if(decodedClean !== currentLocation){
    currentLocation = decodedClean; log("Current location updated: "+decodedClean); announce(`Current location: ${decodedClean}`, false);
    setTimeout(()=>{ announce("When ready, press Voice Destination and speak your destination.", false); },900);
  }
}

/* Map drawing */
function drawMap(){
  const ctx = mapCanvas.getContext('2d'); ctx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
  const cw = mapCanvas.width, ch = mapCanvas.height, margin=40;
  const xs = Object.values(node_coords).map(p=>p[0]); const ys = Object.values(node_coords).map(p=>p[1]);
  const minx = Math.min(...xs), maxx = Math.max(...xs); const miny = Math.min(...ys), maxy = Math.max(...ys);
  const project = (p)=>{ const sx=(p[0]-minx)/(maxx-minx||1); const sy=(p[1]-miny)/(maxy-miny||1); return [margin + Math.floor(sx*(cw-margin*2)), margin + Math.floor(sy*(ch-margin*2))];};
  ctx.strokeStyle="#ddd"; ctx.lineWidth=1;
  for(const a in graph){ for(const b in graph[a]){ if(node_coords[a] && node_coords[b]){ const pa=project(node_coords[a]); const pb=project(node_coords[b]); ctx.beginPath(); ctx.moveTo(pa[0],pa[1]); ctx.lineTo(pb[0],pb[1]); ctx.stroke(); } } }
  ctx.font="14px Arial";
  for(const name in node_coords){ const p=project(node_coords[name]); if(name===currentLocation){ ctx.fillStyle="#ff4444"; ctx.beginPath(); ctx.arc(p[0],p[1],8,0,Math.PI*2); ctx.fill(); } else { ctx.fillStyle="#333"; ctx.beginPath(); ctx.arc(p[0],p[1],4,0,Math.PI*2); ctx.fill(); } ctx.fillStyle="#000"; ctx.fillText(name,p[0]+10,p[1]+4); }
}

/* UI events & keyboard shortcuts */
startBtn.onclick = async ()=> { if(scannerRunning){ announce("Scanner already running.", false); return; } userGesturePerformed=true; await startCamera(); };
stopBtn.onclick = ()=> { stopCamera(); };
restartBtn.onclick = ()=> { stopCamera(); foundResults.clear(); actionsTriggered=false; scanStartTime=Date.now(); setTimeout(()=>{ startBtn.click(); },300); };
voiceDestBtn.onclick = ()=> { userGesturePerformed=true; ask_destination_via_voice(); };
mapBtn.onclick = ()=> { drawMap(); mapModal.style.display='flex'; announce("Map opened.", false); };
closeMap.onclick = ()=> { mapModal.style.display='none'; announce("Map closed.", false); };
window.addEventListener('keydown',(e)=>{ if(e.key==='s'||e.key==='S'){ startBtn.click(); } if(e.key==='v'||e.key==='V'){ voiceDestBtn.click(); } if(e.key==='m'||e.key==='M'){ mapBtn.click(); } if(e.key==='r'||e.key==='R'){ restartBtn.click(); } if(e.code==='Space'){ e.preventDefault(); stopBtn.click(); } });

/* OpenCV init */
function onOpenCvReady(){ cvReady=true; log("OpenCV ready"); announce("OpenCV loaded.", false); }
if(typeof cv !== 'undefined'){ if(cv && cv.Mat) onOpenCvReady(); else cv['onRuntimeInitialized']=onOpenCvReady; } else { setTimeout(()=>{ if(!cvReady) announce("OpenCV not loaded; using JS fallback.", false); },7000); }

/* Cleanup */
window.addEventListener('beforeunload', ()=>{ if(stream) stream.getTracks().forEach(t=>t.stop()); speechSynthesis.cancel(); });

/* Init */
announce("Ready. Press Start Scan to begin scanning for three color QR codes.", false);
log("App initialized. Speech recognition available: " + (SR_AVAILABLE? 'yes':'no'));
log("Scan sequence: Red (location) + Green (map) + Blue (accessibility)");

</script>
</body>
</html>
