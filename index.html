<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VI-Friendly Indoor Navigation (Enhanced Step-by-Step)</title>
  <style>
    :root{
      --bg:#000; --card:#0b1220; --accent:#ffd54f; --accent-2:#00e676; --text:#fff;
      --muted:#9aa8b2;
      --btn-h:64px; --btn-font:20px;
    }
    html,body{height:100%; margin:0; background:linear-gradient(180deg,#05070a 0%, #0b0f14 100%); color:var(--text); font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; -webkit-font-smoothing:antialiased;}
    .app {
      max-width: 980px;
      margin: 12px auto;
      padding: 18px;
      padding-bottom: 200px;
      background: linear-gradient(180deg, #071018 0, #07121a 100%);
      border-radius: 14px;
      box-shadow: 0 8px 36px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.02);
    }
    header { display:flex; gap:12px; align-items:center; }
    h1 { font-size:24px; margin:0; color:var(--accent); letter-spacing:0.6px; }
    .subtitle { color: var(--muted); font-size:14px; margin-top:4px; }

    .controls { margin:14px 0; display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .btn { background:var(--accent); color:#000; border:none; padding:12px 18px; border-radius:12px; font-size:var(--btn-font); height:var(--btn-h); min-width:150px; cursor:pointer; box-shadow:0 8px 18px rgba(0,0,0,0.5); }
    .btn.secondary { background:transparent; color:var(--text); border:2px solid rgba(255,255,255,0.06); }
    .btn.ghost { background:transparent; color:var(--accent); border:2px dashed rgba(255,213,79,0.18); }
    .btn:focus { outline:4px solid rgba(255,213,79,0.25); outline-offset:3px; }
    .select { font-size:18px; padding:12px; border-radius:12px; height:var(--btn-h); background:#07141a; color:var(--text); border:1px solid rgba(255,255,255,0.03); min-width:140px; }
    .btn.green { background:#4caf50; color:#fff; }
    .btn.red { background:#f44336; color:#fff; }
    .btn.yellow { background:#ffeb3b; color:#000; }
    .btn.grey { background:#9e9e9e; color:#fff; }

    .main-controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #071018;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1000;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.6);
    }
    .main-controls .controls-row { display: flex; justify-content: space-between; gap: 12px; }
    .main-controls .controls-row:last-child { justify-content: center; }

    .statusBox { margin-top:12px; padding:14px; background:linear-gradient(180deg,#071018,#06121a); border-radius:12px; border:1px solid rgba(0,255,136,0.03); min-height:100px; display:flex; gap:12px; align-items:flex-start; }
    #leftStatus { flex:1; }
    #overlayText { font-weight:800; font-size:20px; color:var(--text); margin-bottom:6px; }
    #srAnnounce { font-size:17px; color:var(--muted); margin-top:6px; }
    #listeningBox { margin-top:10px; font-size:18px; color:#ffb74d; min-height:22px; }

    .navigation-progress { margin-top:10px; padding:12px; background:#0a1520; border-radius:8px; border:1px solid rgba(0,255,136,0.1); }
    .nav-step { padding:8px 12px; margin:4px 0; border-radius:6px; background:#061217; color:var(--muted); font-size:16px; }
    .nav-step.current { background:var(--accent-2); color:#000; font-weight:bold; }
    .nav-step.completed { background:#2e7d32; color:#fff; }

    .scan-progress { margin-top:10px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .progress-pill { padding:10px 14px; border-radius:999px; background:#071018; color:var(--muted); font-size:18px; border:1px solid rgba(255,255,255,0.02); min-width:200px; text-align:center; }
    .progress-pill.found { background:var(--accent-2); color:#000; font-weight:800; border:2px solid rgba(0,64,0,0.7); }

    #previewWrap { display:flex; gap:12px; margin-top:14px; align-items:flex-start; justify-content:center; }
    #previewCanvas {
      max-width: 100%;
      height: auto;
      background: #000;
      border-radius: 10px;
      border: 2px solid #0b1b2a;
      object-fit: cover;
      display:block;
      margin: 0 auto;
    }

    .alerts { padding:12px; border-radius:10px; background:#061217; border:1px solid rgba(255,255,255,0.02); min-height:100px; color:var(--muted); }
    .alerts h4 { margin:0 0 6px 0; color:var(--accent); font-size:16px; }
    .alerts ul { margin:0; padding-left:18px; font-size:16px; color:var(--muted); }
    .alerts li { margin-bottom:6px; }

    #log { margin-top:12px; background:#02060a; color:#b8d3de; padding:12px; border-radius:10px; height:160px; overflow:auto; font-size:14px; border:1px solid rgba(255,255,255,0.02); }

    .map-modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.75); z-index:999; }
    .map-modal .box { background:#071018; padding:14px; max-width:900px; width:95%; max-height:85%; overflow:auto; border-radius:10px; border:2px solid rgba(255,255,255,0.02); color:#fff; }
    #mapCanvas { width:100%; height:auto; border-radius:6px; background:#fff; display:block; }

    footer { margin-top:14px; color:var(--muted); font-size:13px; text-align:center; }

    .visually-hidden { position:absolute !important; height:1px; width:1px; overflow:hidden; clip:rect(1px,1px,1px,1px); white-space:nowrap; }
    @media (max-width:760px){
      #previewCanvas { width:100%; height:260px; }
      .controls { gap:8px; }
      .btn { min-width:120px; font-size:18px; height:56px; }
    }
  </style>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
</head>
<body>
  <div class="app" role="application" aria-labelledby="appTitle">
    <header>
      <div>
        <h1 id="appTitle">VI Indoor Navigation</h1>
        <div class="subtitle">Step-by-step QR navigation with voice guidance</div>
      </div>
    </header>

   <div class="controls" role="region" aria-label="Settings">
    <select id="colorFilter" class="select" aria-label="Filter QR color. Choose Any, Red, Green or Blue">
      <option>Any</option><option>Red</option><option>Green</option><option>Blue</option>
    </select>

    <label style="display:flex; align-items:center; gap:8px; margin-left:6px; color:var(--muted); font-size:16px;">
      <input type="checkbox" id="enableDetect" checked aria-label="Enable object detection"> Enable Object Detection
    </label>
   </div>

   <div class="statusBox" role="status" aria-live="polite">
    <div id="leftStatus">
      <div id="overlayText">Ready – Start Scan to begin. Voice input will be started automatically when needed.</div>
      <div id="srAnnounce" aria-live="polite" role="log">Status messages will be read aloud.</div>
      <div id="listeningBox" aria-hidden="true"></div>
      
      <div id="navigationProgress" class="navigation-progress" style="display:none;">
        <h4 style="color:var(--accent); margin:0 0 8px 0;">Navigation Steps</h4>
        <div id="navStepsList"></div>
      </div>
      
      <div class="scan-progress" aria-hidden="false">
        <div id="progressRed" class="progress-pill" role="status">Red QR: Not found</div>
        <div id="progressGreen" class="progress-pill" role="status">Green QR: Not found</div>
        <div id="progressBlue" class="progress-pill" role="status">Blue QR: Not found</div>
      </div>
    </div>

    <div id="alertsPanel">
      <div class="alerts" aria-live="polite">
        <h4>Object Alerts</h4>
        <ul id="alertsList"><li>No recent alerts</li></ul>
      </div>
    </div>
   </div>

   <div id="previewWrap">
     <canvas id="previewCanvas" width="800" height="600" aria-label="Camera preview for sighted helper"></canvas>
   </div>

   <div id="log" aria-live="polite" role="log"></div>

   <div class="map-modal" id="mapModal" role="dialog" aria-modal="true" aria-labelledby="mapTitle">
     <div class="box">
       <h3 id="mapTitle">Map Preview</h3>
       <canvas id="mapCanvas" width="900" height="600"></canvas>
       <div style="text-align:right; margin-top:8px;">
         <button id="closeMap" class="btn secondary" aria-label="Close map">Close</button>
       </div>
     </div>
   </div>

   <div class="controls main-controls" role="region" aria-label="Main controls">
     <div class="controls-row">
       <button id="startBtn" class="btn green" aria-pressed="false" aria-label="Start scanning for QR codes (S)">Start Scan</button>
       <button id="stopBtn" class="btn red" aria-pressed="false" aria-label="Stop scanning (Space)">Stop Scan</button>
       <button id="voiceDestBtn" class="btn yellow" aria-label="Voice destination input (V)">Voice Destination</button>
     </div>
   </div>

   <footer>Built for visually impaired users – spoken prompts, vibration and object alerts help navigation.</footer>
  </div>

<script>
/* ---------------------------
   DOM Elements & Helpers
   --------------------------- */
const overlayText = document.getElementById('overlayText');
const srAnnounce = document.getElementById('srAnnounce');
const previewCanvas = document.getElementById('previewCanvas');
const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
const canvasDisp = document.createElement('canvas');
const ctxDisp = canvasDisp.getContext('2d', { willReadFrequently: true });
const logEl = document.getElementById('log');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const voiceDestBtn = document.getElementById('voiceDestBtn');
const colorFilterEl = document.getElementById('colorFilter');
const mapBtn = document.getElementById('mapBtn');
const mapModal = document.getElementById('mapModal');
const mapCanvas = document.getElementById('mapCanvas');
const closeMap = document.getElementById('closeMap');
const restartBtn = document.getElementById('restartBtn');
const progressRed = document.getElementById('progressRed');
const progressGreen = document.getElementById('progressGreen');
const progressBlue = document.getElementById('progressBlue');
const enableDetectCheckbox = document.getElementById('enableDetect');
const alertsList = document.getElementById('alertsList');
const navigationProgress = document.getElementById('navigationProgress');
const navStepsList = document.getElementById('navStepsList');

const log = (m) => { 
  console.log(m); 
  const t = new Date().toLocaleTimeString(); 
  logEl.innerText += `[${t}] ${m}\n`; 
  logEl.scrollTop = logEl.scrollHeight; 
};

/* ---------------------------
   Global State Variables
   --------------------------- */
const SCAN_SIZE = 360;
let scanBox = { x: 0, y: 0, size: SCAN_SIZE };
let cvReady = false, animationFrameId = null, stream = null, scannerRunning = false;
let foundResults = new Map(), scanStartTime = Date.now(), currentLocation = null;
let latestDetections = [], actionsTriggered = false;
let cocoModel = null, cocoReady = false;
const DETECTION_INTERVAL_MS = 900, SCORE_THRESHOLD = 0.45, CENTER_TOLERANCE = 0.25;
const DISTANCE_ESTIMATE_SCALE = 1.6; 
let lastDetectTime = 0;
const alertCooldown = 3000; 
const lastAlertAt = {};
const HARMFUL_CLASSES = new Set(['person','chair','couch','bench','dining table','stop sign','tv','suitcase','backpack','bed','toilet']);
let userGesturePerformed = false;
let destinationNode = null;

// Enhanced navigation state
let navigationState = {
  active: false,
  fullPath: [],
  currentStepIndex: 0,
  waitingForQR: false,
  expectedLocation: null,
  waitingForVoice: false,
  skipCount: 0,
  destination: null
};

// Speech Recognition check
let SR_AVAILABLE = false;
try { 
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 
  if (SpeechRecognition) SR_AVAILABLE = true; 
} catch(e){ SR_AVAILABLE=false; }

/* ---------------------------
   Enhanced Text-to-Speech System with Better Timing
   --------------------------- */
const TTS = {
  queue: [], 
  speaking: false,
  currentUtterance: null,
  
  speak(text, interrupt=false) {
    if(!text) return;
    if(interrupt){ 
      this.stop();
      this.queue=[]; 
    }
    this.queue.push(text); 
    this._maybeSpeak();
  },
  
  stop() {
    if (this.currentUtterance) {
      speechSynthesis.cancel();
      this.currentUtterance = null;
    }
    this.speaking = false;
  },
  
  _maybeSpeak() {
    if(this.speaking) return;
    const next = this.queue.shift();
    if(!next) return;
    
    this.speaking = true;
    this.currentUtterance = new SpeechSynthesisUtterance(next); 
    this.currentUtterance.rate = 1.0;
    
    this.currentUtterance.onend = () => { 
      this.speaking = false; 
      this.currentUtterance = null;
      setTimeout(()=>this._maybeSpeak(), 80); 
    };
    
    this.currentUtterance.onerror = () => { 
      this.speaking = false; 
      this.currentUtterance = null;
      setTimeout(()=>this._maybeSpeak(), 80); 
    };
    
    speechSynthesis.speak(this.currentUtterance);
  },
  
  async waitForFinish() {
    return new Promise(resolve => {
      const checkFinished = () => {
        if (!this.speaking && this.queue.length === 0 && !speechSynthesis.speaking) {
          resolve();
        } else {
          setTimeout(checkFinished, 100);
        }
      };
      checkFinished();
    });
  },

  // Force a complete stop and wait for silence
  async forceStopAndWait() {
    this.stop();
    this.queue = [];
    speechSynthesis.cancel();
    
    // Wait for speechSynthesis to actually stop
    return new Promise(resolve => {
      const checkSilence = () => {
        if (!speechSynthesis.speaking) {
          // Add extra delay to ensure complete silence
          setTimeout(resolve, 300);
        } else {
          setTimeout(checkSilence, 100);
        }
      };
      checkSilence();
    });
  }
};

function announce(text, interrupt=false) {
  overlayText.textContent = text;
  srAnnounce.textContent = text;
  TTS.speak(text, interrupt);
  log(`[ANNOUNCE] ${text}`);
}

/* ---------------------------
   QR Code Detection Functions
   --------------------------- */
function createColorMask(imageData, color) {
  const data = imageData.data;
  const w = imageData.width, h = imageData.height;
  const out = new Uint8ClampedArray(data.length);
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i+1], b = data[i+2];
    let hit = false;
    
    if (color === 'red') {
      hit = (r > g + 25 && r > b + 25 && r > 90) || (r > 140 && r > g * 1.3 && r > b * 1.3);
    } else if (color === 'green') {
      hit = (g > r + 25 && g > b + 25 && g > 90) || (g > 140 && g > r * 1.2 && g > b * 1.2);
    } else if (color === 'blue') {
      hit = (b > r + 20 && b > g + 20 && b > 70) || (b > 110 && b > r * 1.05 && b > g * 1.05);
    }
    
    if (hit) {
      out[i] = 255; out[i+1] = 255; out[i+2] = 255; out[i+3] = 255;
    } else {
      out[i] = 0; out[i+1] = 0; out[i+2] = 0; out[i+3] = 255;
    }
  }
  return new ImageData(out, w, h);
}

function extractColorChannel(imageData, channel) {
  const data = imageData.data;
  const out = new Uint8ClampedArray(data.length);
  
  for (let i=0;i<data.length;i+=4){
    const r = data[i], g = data[i+1], b = data[i+2];
    let intensity = 0;
    
    if (channel === 'red') intensity = r;
    else if (channel === 'green') intensity = g;
    else intensity = Math.max(b, Math.floor((b*1.6 + Math.max(r,g)*0.2)));
    
    intensity = Math.min(255, Math.max(0, intensity));
    out[i] = out[i+1] = out[i+2] = intensity;
    out[i+3] = 255;
  }
  return new ImageData(out, imageData.width, imageData.height);
}

function enhanceBlueContrast(imageData) {
  const data = imageData.data;
  const out = new Uint8ClampedArray(data.length);
  
  for (let i=0;i<data.length;i+=4){
    const r = data[i], g = data[i+1], b = data[i+2];
    let intensity = b;
    
    if (b > r && b > g) intensity = Math.min(255, Math.round(b * 1.8));
    else if (b > 70) intensity = Math.min(255, Math.round(b * 1.3));
    else intensity = Math.round((r+g+b)/3 * 0.55);
    
    out[i]=out[i+1]=out[i+2]=intensity; out[i+3]=255;
  }
  return new ImageData(out, imageData.width, imageData.height);
}

function detectWithOpenCV(imageData, color) {
  if (!cvReady) return null;
  try {
    const src = cv.matFromImageData(imageData);
    const rgb = new cv.Mat();
    cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
    const hsv = new cv.Mat();
    cv.cvtColor(rgb, hsv, cv.COLOR_RGB2HSV);

    const mask = new cv.Mat();
    if (color === 'red') {
      const lower1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 80, 40, 0]);
      const upper1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [10, 255, 255, 255]);
      const lower2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [170, 80, 40, 0]);
      const upper2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 255, 255, 255]);
      const m1 = new cv.Mat(), m2 = new cv.Mat();
      cv.inRange(hsv, lower1, upper1, m1);
      cv.inRange(hsv, lower2, upper2, m2);
      cv.add(m1, m2, mask);
      m1.delete(); m2.delete(); lower1.delete(); upper1.delete(); lower2.delete(); upper2.delete();
    } else if (color === 'green') {
      const low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [35, 60, 40, 0]);
      const high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [85, 255, 255, 255]);
      cv.inRange(hsv, low, high, mask);
      low.delete(); high.delete();
    } else {
      const low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [90, 40, 30, 0]);
      const high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [140, 255, 255, 255]);
      cv.inRange(hsv, low, high, mask);
      low.delete(); high.delete();
    }

    const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
    cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
    cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
    const rgba = new cv.Mat();
    cv.cvtColor(mask, rgba, cv.COLOR_GRAY2RGBA);

    const out = new ImageData(new Uint8ClampedArray(rgba.data), rgba.cols, rgba.rows);

    src.delete(); rgb.delete(); hsv.delete(); mask.delete(); kernel.delete(); rgba.delete();
    return out;
  } catch (e) {
    console.warn("OpenCV detect failed:", e);
    return null;
  }
}

function detect_colored_qr_in_frame_js(imageData, targetColor=null) {
  const COLORS = ['red','green','blue'];
  
  for (const color of COLORS) {
    if (targetColor && color !== targetColor) continue;
    
    try {
      const chImg = extractColorChannel(imageData, color);
      const code = jsQR(chImg.data, chImg.width, chImg.height, { inversionAttempts: 'attemptBoth' });
      if (code && code.data) {
        let boxArea = null;
        if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
          const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
          const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
          boxArea = Math.abs(w*h);
        }
        return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Enhanced-Channel', location: code.location || null, boxArea };
      }
    } catch(e){ console.warn('Enhanced channel decode error', color, e); }

    if (color === 'blue') {
      try {
        const maskImg = createColorMask(imageData, color);
        const code = jsQR(maskImg.data, maskImg.width, maskImg.height, { inversionAttempts: 'attemptBoth' });
        if (code && code.data) {
          let boxArea = null;
          if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
            const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
            const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
            boxArea = Math.abs(w*h);
          }
          return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Color-Mask', location: code.location || null, boxArea };
        }
      } catch(e){ console.warn('Color mask decode error', color, e); }
    }

    if (cvReady) {
      try {
        const cvProcessed = detectWithOpenCV(imageData, color);
        if (cvProcessed) {
          const code = jsQR(cvProcessed.data, cvProcessed.width, cvProcessed.height, { inversionAttempts: 'attemptBoth' });
          if (code && code.data) {
            let boxArea = null;
            if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
              const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
              const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
              boxArea = Math.abs(w*h);
            }
            return { found: true, decoded: code.data.trim(), colorFound: color, method: 'OpenCV-HSV', location: code.location || null, boxArea };
          }
        }
      } catch(e){ console.warn('OpenCV approach failed for', color, e); }
    }

    if (color === 'blue') {
      try {
        const enhanced = enhanceBlueContrast(imageData);
        const code = jsQR(enhanced.data, enhanced.width, enhanced.height, { inversionAttempts: 'attemptBoth' });
        if (code && code.data) {
          let boxArea = null;
          if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
            const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
            const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
            boxArea = Math.abs(w*h);
          }
          return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Blue-Enhanced', location: code.location || null, boxArea };
        }
      } catch(e){ console.warn('Blue enhancement failed', e); }
    }
  }
  return { found: false };
}

/* ---------------------------
   Progress & UI Updates
   --------------------------- */
function updateProgressDisplay() {
  const colors = ['red', 'green', 'blue'];
  let foundCount = 0;
  
  colors.forEach(color => {
    const el = color === 'red' ? progressRed : color === 'green' ? progressGreen : progressBlue;
    if (foundResults.has(color)) {
      foundCount++;
      el.classList.add('found');
      el.textContent = `${color.toUpperCase()} QR: ${foundResults.get(color).decoded}`;
    } else {
      el.classList.remove('found');
      el.textContent = `${color.charAt(0).toUpperCase() + color.slice(1)} QR: Scanning...`;
    }
  });
  
  if (foundCount > 0 && foundCount < 3) {
    const remaining = 3 - foundCount;
    announce(`${foundCount} of 3 QR codes found. ${remaining} remaining.`, false);
  }
  
  console.log(`Progress: ${foundCount}/3 QR codes found`);
}

function updateAlertsList(dets) {
  alertsList.innerHTML = '';
  for (const d of dets) {
    const li = document.createElement('li');
    li.textContent = `${d.class} ${(d.score*100).toFixed(0)}%`;
    alertsList.appendChild(li);
  }
  if (dets.length === 0) {
    const li = document.createElement('li');
    li.textContent = 'No recent alerts';
    alertsList.appendChild(li);
  }
}

/* ---------------------------
   Vibration Helpers
   --------------------------- */
let lastVibrateAt = 0;
function vibrateProximityFromRatio(ratio) {
  if (!('vibrate' in navigator)) return;
  const now = Date.now();
  if (now - lastVibrateAt < 160) return;
  lastVibrateAt = now;
  const intensity = Math.min(1, Math.max(0, (ratio - 0.02) / 0.6));
  const dur = Math.round(40 + intensity * 280);
  const pattern = [dur, 40];
  try { navigator.vibrate(pattern); } catch(e){}
}

function vibrateArrival() {
  if (!('vibrate' in navigator)) return;
  try { navigator.vibrate([80,40,80,40,120]); } catch(e){}
}

/* ---------------------------
   Camera Functions
   --------------------------- */
async function startCamera() {
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }, 
      audio: false
    });
    
    const video = document.createElement('video');
    video.autoplay = true; 
    video.playsInline = true; 
    video.muted = true;
    video.srcObject = stream;
    await video.play();

    canvasDisp.width = video.videoWidth || 1280;
    canvasDisp.height = video.videoHeight || 720;
    previewCanvas.width = Math.min(1280, canvasDisp.width);
    previewCanvas.height = Math.min(720, canvasDisp.height);

    // Center scan box
    scanBox.size = Math.min(SCAN_SIZE, Math.floor(Math.min(canvasDisp.width, canvasDisp.height) * 0.5));
    scanBox.x = Math.floor((canvasDisp.width - scanBox.size)/2);
    scanBox.y = Math.floor((canvasDisp.height - scanBox.size)/2);

    scanStartTime = Date.now();
    foundResults.clear();
    actionsTriggered = false;
    scannerRunning = true;
    
    // Different announcements based on context
    if (navigationState.waitingForQR) {
      announce(`Camera started. Scanning for ${navigationState.expectedLocation} QR code.`, true);
    } else {
      announce("Camera started. Scanning for QR codes. Point the phone at the QR.", true);
      updateProgressDisplay();
    }
    
    processFrame(video);
    startBtn.setAttribute('aria-pressed','true');
    userGesturePerformed = true;
    return true;
  } catch(e) {
    announce("Camera access denied or unavailable. Check permissions and try again.", true);
    log("Camera error: " + e);
    return false;
  }
}

function stopCamera() {
  if (stream) stream.getTracks().forEach(t => t.stop());
  if (animationFrameId) { 
    cancelAnimationFrame(animationFrameId); 
    animationFrameId = null; 
  }
  scannerRunning = false;
  startBtn.setAttribute('aria-pressed','false');
  log("Camera stopped.");
}

/* ---------------------------
   Object Detection Model Loading
   --------------------------- */
async function loadCocoModel() {
  try {
    log("Loading coco-ssd...");
    cocoModel = await cocoSsd.load();
    cocoReady = true;
    log("coco-ssd loaded");
  } catch(e) {
    cocoReady = false;
    log("coco load failed: " + e);
  }
}
loadCocoModel();

/* ---------------------------
   Canvas Drawing Functions
   --------------------------- */
function drawPreviewFrame(tmpCanvas) {
  try {
    previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    previewCtx.drawImage(tmpCanvas, 0, 0, previewCanvas.width, previewCanvas.height);

    // Overlay scan box (scaled)
    const sx = previewCanvas.width / tmpCanvas.width;
    const sy = previewCanvas.height / tmpCanvas.height;
    previewCtx.strokeStyle = 'rgba(0,255,128,0.9)';
    previewCtx.lineWidth = Math.max(2, Math.round(previewCanvas.width * 0.004));
    previewCtx.strokeRect(Math.round(scanBox.x*sx), Math.round(scanBox.y*sy), Math.round(scanBox.size*sx), Math.round(scanBox.size*sy));

    // Overlay object detections
    if (latestDetections && latestDetections.length && enableDetectCheckbox.checked) {
      previewCtx.save();
      previewCtx.lineWidth = Math.max(2, Math.round(previewCanvas.width * 0.004));
      for (const d of latestDetections) {
        const [x,y,w,h] = d.bbox;
        const rx = Math.round(x * sx), ry = Math.round(y * sy), rw = Math.round(w * sx), rh = Math.round(h * sy);
        previewCtx.strokeStyle = 'rgba(255,80,80,0.95)';
        previewCtx.fillStyle = 'rgba(255,80,80,0.85)';
        previewCtx.beginPath();
        previewCtx.strokeRect(rx, ry, rw, rh);
        const label = `${d.class} ${(d.score*100).toFixed(0)}%`;
        previewCtx.font = `${14}px Arial`;
        const tw = previewCtx.measureText(label).width + 10;
        previewCtx.fillRect(rx, Math.max(ry-22, 0), tw, 20);
        previewCtx.fillStyle = '#fff';
        previewCtx.fillText(label, rx+5, Math.max(ry-8, 12));
        previewCtx.fillStyle = 'rgba(255,80,80,0.85)';
      }
      previewCtx.restore();
    }
  } catch(e) { 
    console.warn("drawPreviewFrame error", e); 
  }
}

/* ---------------------------
   Main Processing Loop
   --------------------------- */
let qrDecoderBusy = false, frameSkipCounter = 0;
async function processFrame(video) {
  if (!scannerRunning) return;
  animationFrameId = requestAnimationFrame(() => processFrame(video));
  if (!video || video.readyState < 2) return;

  frameSkipCounter++;
  if (frameSkipCounter % 2 !== 0 && foundResults.size < 3 && !navigationState.waitingForQR) return;

  // Ensure canvas sizes
  canvasDisp.width = video.videoWidth || canvasDisp.width;
  canvasDisp.height = video.videoHeight || canvasDisp.height;

  // Draw frame into processing canvas
  ctxDisp.drawImage(video, 0, 0, canvasDisp.width, canvasDisp.height);

  // Create temporary preview canvas
  const tmp = document.createElement('canvas');
  tmp.width = canvasDisp.width; 
  tmp.height = canvasDisp.height;
  const tmpCtx = tmp.getContext('2d');
  tmpCtx.drawImage(canvasDisp, 0, 0);
  
  // Draw scan box for sighted helper
  tmpCtx.strokeStyle = '#00ff88'; 
  tmpCtx.lineWidth = Math.max(2, Math.round(canvasDisp.width * 0.004));
  tmpCtx.strokeRect(scanBox.x, scanBox.y, scanBox.size, scanBox.size);

  // Draw object detection boxes if available
  if (latestDetections && latestDetections.length > 0 && enableDetectCheckbox.checked) {
    tmpCtx.lineWidth = Math.max(2, Math.round(canvasDisp.width * 0.004));
    for (const d of latestDetections) {
      tmpCtx.strokeStyle = 'rgba(255,80,80,0.9)';
      tmpCtx.fillStyle = 'rgba(255,80,80,0.8)';
      const [x,y,w,h] = d.bbox;
      tmpCtx.strokeRect(x, y, w, h);
      const label = `${d.class} ${(d.score*100).toFixed(0)}%`;
      const labelW = tmpCtx.measureText(label).width + 10;
      tmpCtx.fillRect(x, Math.max(y-22,0), labelW, 20);
      tmpCtx.fillStyle = '#fff';
      tmpCtx.fillText(label, x+5, Math.max(y-8, 12));
      tmpCtx.fillStyle = 'rgba(255,80,80,0.8)';
    }
  }

  // Draw to visible preview
  drawPreviewFrame(tmp);

  if (qrDecoderBusy) return;
  qrDecoderBusy = true;

  setTimeout(async () => {
    try {
      // Read scan area image data
      const imageData = ctxDisp.getImageData(scanBox.x, scanBox.y, scanBox.size, scanBox.size);
      
      // Handle navigation QR scanning differently
      if (navigationState.waitingForQR) {
        const detection = detect_colored_qr_in_frame_js(imageData, null);
        if (detection.found && detection.decoded) {
          const scannedLocation = detection.decoded.trim();
          handleNavigationQRScan(scannedLocation);
        }
      } else {
        // Normal initial 3-color QR scanning
        const targetFilter = (colorFilterEl.value === "Any") ? null : colorFilterEl.value.toLowerCase();
        const colorOrder = targetFilter ? [targetFilter] : ['blue','red','green'];
        
        for (const color of colorOrder) {
          if (foundResults.has(color)) continue;
          
          const detection = detect_colored_qr_in_frame_js(imageData, color);
          if (detection.found && detection.decoded) {
            const decodedClean = detection.decoded.trim();
            foundResults.set(color, { 
              decoded: decodedClean, 
              method: detection.method || 'unknown', 
              boxArea: detection.boxArea || null 
            });
            
            announce(`${color} QR found: ${decodedClean}`, true);
            updateProgressDisplay();
            
            if (detection.boxArea) {
              const scanArea = scanBox.size * scanBox.size;
              const ratio = detection.boxArea / scanArea;
              vibrateProximityFromRatio(ratio);
            }
            
            handleInitialQRDecoded(decodedClean, color);
            break;
          }
        }

        // Check if ALL 3 colors are found before triggering
        const requiredColors = ['red', 'green', 'blue'];
        const foundColors = Array.from(foundResults.keys());
        const allColorsFound = requiredColors.every(color => foundColors.includes(color));
        
        if (!actionsTriggered && allColorsFound) {
          console.log('TRIGGERING ALL ACTIONS - All 3 QR codes detected!');
          triggerAllActionsOnce();
        }
      }

      // Object detection logic
      const now = performance.now();
      if (enableDetectCheckbox.checked && cocoReady && (now - lastDetectTime > DETECTION_INTERVAL_MS)) {
        lastDetectTime = now;
        try {
          const off = document.createElement('canvas');
          const D_W = 480;
          const scale = D_W / canvasDisp.width;
          off.width = D_W;
          off.height = Math.floor(canvasDisp.height * scale);
          const offCtx = off.getContext('2d');
          offCtx.drawImage(canvasDisp, 0, 0, off.width, off.height);
          const predictions = await cocoModel.detect(off);
          const preds = predictions.filter(p => p.score >= SCORE_THRESHOLD);
          const scaleBack = canvasDisp.width / off.width;
          latestDetections = preds.map(p => {
            const [x,y,w,h] = p.bbox;
            return { class: p.class, score: p.score, bbox: [x*scaleBack, y*scaleBack, w*scaleBack, h*scaleBack] };
          });

          if (latestDetections.length) {
            updateAlertsList(latestDetections.slice(0,4));
          } else {
            updateAlertsList([]);
          }

          // Obstacle detection logic
          let candidate = null;
          const fh = canvasDisp.height;
          const fw = canvasDisp.width;
          for (const det of latestDetections) {
            if (!HARMFUL_CLASSES.has(det.class)) continue;
            const [x,y,w,h] = det.bbox;
            const cx = x + w/2;
            const centerDelta = Math.abs(cx - fw/2) / fw;
            const score = (h / fh) * (1.0 - Math.min(centerDelta / 0.5, 1.0));
            if (!candidate || score > candidate.score) candidate = {det, score};
          }
          if (candidate) {
            const det = candidate.det;
            const [x,y,w,h] = det.bbox;
            const cx = x + w/2;
            const centerDelta = Math.abs(cx - fw/2) / fw;
            const isAhead = (centerDelta <= CENTER_TOLERANCE) && (h / fh >= 0.06);
            if (isAhead) {
              const cls = det.class;
              const nowTs = Date.now();
              if (!lastAlertAt[cls] || (nowTs - lastAlertAt[cls] > alertCooldown)) {
                const ratio = (h / fh);
                let distMeters = (DISTANCE_ESTIMATE_SCALE / Math.max(ratio, 0.02));
                distMeters = Math.min(Math.max(distMeters, 0.2), 50.0);
                if (distMeters <= 5.0) {
                  announce(`Obstacle ahead: ${cls}, approximately ${distMeters.toFixed(1)} meters.`, false);
                  lastAlertAt[cls] = nowTs;
                  log(`[OBSTACLE] ${cls} @ ${distMeters.toFixed(1)}m`);
                }
              }
            }
          }
        } catch(e) {
          console.warn("Object detection error", e);
        }
      }

    } catch(e) {
      console.error("Frame processing error:", e);
    } finally {
      qrDecoderBusy = false;
    }
  }, 36);
}

/* ---------------------------
   Initial QR Handling
   --------------------------- */
function handleInitialQRDecoded(decoded, color) {
  // Only set current location from red QR during initial setup
  if (color === 'red' && !currentLocation) {
    currentLocation = decoded.trim();
    log("Initial location set: " + currentLocation);
  }
}

/* ---------------------------
   Setup Complete After 3 QRs Found
   --------------------------- */
function triggerAllActionsOnce() {
  if (actionsTriggered) return;
  
  const requiredColors = ['red', 'green', 'blue'];
  const foundColors = Array.from(foundResults.keys());
  const allColorsFound = requiredColors.every(color => foundColors.includes(color));
  
  if (!allColorsFound) return;
  
  actionsTriggered = true;
  
  log("ALL THREE COLOR QR CODES DETECTED - SETUP COMPLETE");
  announce("All three QR codes detected. Setting up navigation system.", true);
  
  const redQR = foundResults.get('red')?.decoded || '';
  const greenQR = foundResults.get('green')?.decoded || '';
  const blueQR = foundResults.get('blue')?.decoded || '';
  
  // Set current location
  currentLocation = redQR;
  
  stopCamera();
  
  // Hide initial progress pills
  document.querySelector('.scan-progress').style.display = 'none';
  
  // Sequence the announcements with proper timing
  setTimeout(() => { 
    log("Map info: " + greenQR); 
    announce("Map information loaded.", false); 
    drawMap(); 
    mapModal.style.display = 'flex'; 
  }, 700);
  
  setTimeout(() => { 
    log("Accessibility: " + blueQR); 
    announce("Accessibility information: " + blueQR, false); 
  }, 1500);
  
  setTimeout(() => { 
    log("Current location confirmed: " + redQR); 
    announce("Your current location is " + redQR, false); 
  }, 2500);
  
  setTimeout(async () => { 
    // Close map modal
    mapModal.style.display = 'none';
    
    if (SR_AVAILABLE) { 
      // Wait for TTS to finish before starting voice recognition
      await TTS.waitForFinish();
      announce("I will now listen for your destination.", true); 
      // Wait for this announcement to finish
      await TTS.waitForFinish();
      setTimeout(() => {
        ask_destination_via_voice();
      }, 500);
    } else { 
      show_destination_modal(); 
    } 
  }, 4000);
}

/* ---------------------------
   Enhanced Speech Recognition System with Proper Timing
   --------------------------- */
function startSpeechRecognition({lang='en-US', interim=true, timeout=15000, onInterim=null} = {}) {
  return new Promise((resolve) => {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) { resolve(null); return; }
    
    let recognition;
    try { recognition = new SR(); } catch(e) { resolve(null); return; }
    
    recognition.lang = lang; 
    recognition.interimResults = interim; 
    recognition.maxAlternatives = 3;
    recognition.continuous = false;
    
    let finalTranscript = '';
    let resolved = false;
    
    const timer = setTimeout(() => {
      if (!resolved) { 
        resolved = true; 
        try { recognition.stop(); } catch(e){}; 
        resolve(null); 
      }
    }, timeout);
    
    recognition.onresult = (evt) => {
      const results = Array.from(evt.results);
      const interimText = results.map(r => r[0].transcript).join(' ');
      if (onInterim) onInterim(interimText);
      
      for (const r of results) { 
        if (r.isFinal) finalTranscript = r[0].transcript; 
      }
      
      if (finalTranscript && !resolved) { 
        resolved = true; 
        clearTimeout(timer); 
        try { recognition.stop(); } catch(e){}; 
        resolve(finalTranscript.trim()); 
      }
    };
    
    recognition.onend = () => {
      if (resolved) return;
      resolved = true; 
      clearTimeout(timer); 
      resolve(finalTranscript ? finalTranscript.trim() : null);
    };
    
    recognition.onerror = (e) => {
      if (resolved) return;
      resolved = true; 
      clearTimeout(timer); 
      try { recognition.stop(); } catch(err){}; 
      resolve(null);
    };
    
    try { recognition.start(); } catch(e) { clearTimeout(timer); resolve(null); }
  });
}

function interpretConfirmation(text) {
  if (!text) return 'unknown';
  const s = text.toLowerCase().trim();
  
  const yesPatterns = ['yes', 'yeah', 'yep', 'yup', 'sure', 'correct', 'right', 'ok', 'okay', 'confirm', 'affirmative'];
  const noPatterns = ['no', 'nope', 'nah', 'wrong', 'incorrect', 'cancel', 'stop'];
  
  const hasYes = yesPatterns.some(pattern => s.includes(pattern));
  const hasNo = noPatterns.some(pattern => s.includes(pattern));
  
  if (hasYes && !hasNo) return 'yes';
  if (hasNo && !hasYes) return 'no'; 
  if (hasYes && hasNo) return 'ambiguous';
  return 'unknown';
}

/* ---------------------------
   Navigation Graph & Map Data
   --------------------------- */
const node_coords = {
  "Female Toilet (NGT1)": [2009, 1357],
  "Male Toilet (NGT2)": [1955, 1357],
  "N001 (backdoor)": [2100, 1135],
  "N001": [1907, 1121],
  "N002": [1651, 1097],
  "N003": [1387, 1074],
  "N004": [892, 1097],
  "N005": [638, 1115],
  "N006": [383, 1139],
  "N007": [127, 1158],
  "N008": [4, 1330],
  "Female Toilet (NGT5)": [357, 1350],
  "Male Toilet (NGT4)": [403, 1351],
  "N009": [492, 1330],
  "N010": [822, 1335],
  "N011": [1251, 1340],
  "N012": [1597, 1340],
};

const graph_raw = {
  "Female Toilet (NGT1)": {"Male Toilet (NGT2)": 1.89},
  "N001": {"Female Toilet (NGT1)": 9.00, "N001 (backdoor)": 6.77, "N002": 9.00},
  "N002": {"N003": 9.28},
  "N003": {"N004": 17.35},
  "N004": {"N005": 8.91},
  "N005": {"N006": 8.97},
  "N006": {"Male Toilet (NGT4)": 7.45, "Female Toilet (NGT5)": 7.44, "N007": 8.99},
  "N007": {"N008": 7.40},
  "N008": {"Female Toilet (NGT5)": 12.38},
  "Female Toilet (NGT5)": {"Male Toilet (NGT4)": 1.61},
  "Male Toilet (NGT4)": {"N009": 3.20},
  "N009": {"N010": 11.55},
  "N010": {"N011": 15.02},
  "N011": {"N012": 12.11},
  "N012": {"Male Toilet (NGT2)": 12.55}
};

function add_bidirectional_edges(graph_in) {
  const new_graph = {};
  for (const k in graph_in) new_graph[k] = {};
  for (const from in graph_in) {
    for (const to in graph_in[from]) {
      const w = graph_in[from][to];
      new_graph[from][to] = w;
      if (!new_graph[to]) new_graph[to] = {};
      new_graph[to][from] = w;
    }
  }
  return new_graph;
}

const graph = add_bidirectional_edges(graph_raw);

/* ---------------------------
   Map Drawing Functions
   --------------------------- */
function drawMap() {
  const ctx = mapCanvas.getContext('2d');
  ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

  const cw = mapCanvas.width, ch = mapCanvas.height, margin = 40;
  const xs = Object.values(node_coords).map(p => p[0]);
  const ys = Object.values(node_coords).map(p => p[1]);
  const minx = Math.min(...xs), maxx = Math.max(...xs);
  const miny = Math.min(...ys), maxy = Math.max(...ys);

  const project = (p) => {
    const sx = (p[0] - minx) / (maxx - minx || 1);
    const sy = (p[1] - miny) / (maxy - miny || 1);
    return [
      margin + Math.floor(sx * (cw - margin * 2)),
      margin + Math.floor(sy * (ch - margin * 2))
    ];
  };

  // Draw edges
  ctx.strokeStyle = "#bbb";
  ctx.lineWidth = 1;
  for (const a in graph) {
    for (const b in graph[a]) {
      if (node_coords[a] && node_coords[b]) {
        const pa = project(node_coords[a]);
        const pb = project(node_coords[b]);
        ctx.beginPath();
        ctx.moveTo(pa[0], pa[1]);
        ctx.lineTo(pb[0], pb[1]);
        ctx.stroke();
      }
    }
  }

  // Draw navigation path if active
  if (navigationState.active && navigationState.fullPath.length > 1) {
    ctx.strokeStyle = "#ff6b35";
    ctx.lineWidth = 4;
    ctx.beginPath();
    for (let i = 0; i < navigationState.fullPath.length - 1; i++) {
      const current = navigationState.fullPath[i];
      const next = navigationState.fullPath[i + 1];
      if (node_coords[current] && node_coords[next]) {
        const pa = project(node_coords[current]);
        const pb = project(node_coords[next]);
        if (i === 0) ctx.moveTo(pa[0], pa[1]);
        ctx.lineTo(pb[0], pb[1]);
      }
    }
    ctx.stroke();
  }

  // Prepare labels
  const labels = [];
  ctx.font = "12px Arial";
  for (const name in node_coords) {
    const p = project(node_coords[name]);
    const text = name;
    const padding = 6;
    const textW = Math.min(300, ctx.measureText(text).width);
    let lx = p[0] + 8;
    let ly = p[1] - 6;
    const labelH = 18;

    if (lx + textW + padding * 2 > cw - margin) lx = p[0] - textW - padding * 2 - 8;
    if (lx < margin) lx = margin;
    if (ly < margin) ly = margin;

    labels.push({ name, p, lx, ly, textW, labelH, padding });
  }

  // Prevent label overlaps
  for (let i = 0; i < labels.length; i++) {
    const a = labels[i];
    for (let j = 0; j < i; j++) {
      const b = labels[j];
      const aLeft = a.lx, aRight = a.lx + a.textW + a.padding * 2;
      const aTop = a.ly, aBottom = a.ly + a.labelH + a.padding;
      const bLeft = b.lx, bRight = b.lx + b.textW + b.padding * 2;
      const bTop = b.ly, bBottom = b.ly + b.labelH + b.padding;
      const overlapX = !(aRight < bLeft || aLeft > bRight);
      const overlapY = !(aBottom < bTop || aTop > bBottom);
      if (overlapX && overlapY) {
        a.ly = bBottom + 4;
      }
    }
  }

  // Draw nodes and labels with proper highlighting
  for (const lbl of labels) {
    const p = lbl.p;

    // Node highlighting logic
    if (currentLocation && lbl.name === currentLocation) {
      // Current location in red
      ctx.fillStyle = "#ff4444";
      ctx.beginPath();
      ctx.arc(p[0], p[1], 10, 0, Math.PI * 2);
      ctx.fill();
    } else if (destinationNode && lbl.name === destinationNode) {
      // Destination in green
      ctx.fillStyle = "#22bb33";
      ctx.beginPath();
      ctx.arc(p[0], p[1], 9, 0, Math.PI * 2);
      ctx.fill();
    } else if (navigationState.active && navigationState.fullPath.includes(lbl.name)) {
      // Waypoint in orange
      ctx.fillStyle = "#ff9800";
      ctx.beginPath();
      ctx.arc(p[0], p[1], 7, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Normal nodes
      ctx.fillStyle = "#333";
      ctx.beginPath();
      ctx.arc(p[0], p[1], 5, 0, Math.PI * 2);
      ctx.fill();
    }

    // Label box + text
    const bx = lbl.lx, by = lbl.ly - 4;
    const bw = lbl.textW + lbl.padding * 2;
    const bh = lbl.labelH + lbl.padding / 1.5;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    roundRect(ctx, bx, by, bw, bh, 6, true, false);
    ctx.fillStyle = '#000';
    ctx.fillText(lbl.name, bx + lbl.padding, by + bh / 1.35);

    // Connection line
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(p[0], p[1]);
    ctx.lineTo(bx + 4, by + bh / 2);
    ctx.stroke();
  }
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

/* ---------------------------
   Destination Selection Functions
   --------------------------- */
function show_destination_modal() {
  if (!currentLocation) { 
    alert("No current location detected. Please scan QR codes first."); 
    return; 
  }
  
  const candidates = Object.keys(node_coords).filter(n => n !== currentLocation);
  const candidateList = candidates.map((p,i)=>`${i+1}. ${p}`).join('\n');
  announce("Opening text selection. Check the screen for options.", false);
  
  const dest = prompt(`Current: ${currentLocation}\nAvailable:\n${candidateList}\n\nType name or number:`);
  if (!dest) { 
    announce("No destination selected.", false); 
    return; 
  }
  
  let destination = dest.trim();
  const destNumber = parseInt(destination);
  if (!isNaN(destNumber) && destNumber >=1 && destNumber <= candidates.length) {
    destination = candidates[destNumber-1];
  } else {
    const best = findBestLocationMatch(destination, candidates);
    if (best) {
      destination = best;
    } else { 
      announce("Destination not found. Please try voice input.", false); 
      setTimeout(()=>ask_destination_via_voice(), 600); 
      return; 
    }
  }
  
  announce(`You selected ${destination}. Confirming.`, false);
  if (confirm(`Navigate to: ${destination}?`)) {
    start_navigation(destination);
  } else { 
    announce("Selection cancelled. Try again.", false); 
    setTimeout(()=>show_destination_modal(), 500); 
  }
}

function findBestLocationMatch(input, candidates) {
  const s = input.toLowerCase().trim();
  let m = candidates.find(c=>c.toLowerCase()===s);
  if (m) return m;
  m = candidates.find(c=>c.toLowerCase().includes(s));
  if (m) return m;
  m = candidates.find(c=>c.toLowerCase().split(' ').some(word => s.includes(word) || word.includes(s)));
  if (m) return m;
  return null;
}

async function ask_destination_via_voice() {
  if (!currentLocation) { 
    announce("No current location. Scan first.", false); 
    return; 
  }
  
  if (!SR_AVAILABLE) { 
    announce("Speech recognition not available. Please use text input.", false); 
    show_destination_modal(); 
    return; 
  }
  
  let tries = 0;
  while (tries < 4) {
    tries++;
    
    // CRITICAL FIX: Force stop all speech and wait for complete silence
    await TTS.forceStopAndWait();
    
    announce("Please say your destination after the beep.", true);
    
    // Wait for TTS to finish completely
    await TTS.waitForFinish();
    
    // Additional safety delay to ensure complete silence
    await new Promise(r=>setTimeout(r, 1000));
    
    const interimBox = document.getElementById('listeningBox');
    interimBox.style.display = 'block'; 
    interimBox.textContent = "Listening… (speak now)";
    
    const transcript = await startSpeechRecognition({
      lang:'en-US', 
      interim:true, 
      timeout:12000, 
      onInterim:(t)=>{ interimBox.textContent = "Listening… " + t; }
    });
    
    interimBox.textContent = '';
    interimBox.style.display = 'none';
    
    if (!transcript) {
      log("No transcript received");
      if (!userGesturePerformed && tries === 1) {
        await TTS.forceStopAndWait();
        announce("I could not access the microphone automatically. Please press the Voice Destination button and allow microphone access, then speak after the beep.", false);
        voiceDestBtn.classList.add('secondary');
        await TTS.waitForFinish();
        await new Promise(r=>setTimeout(r,1000));
        continue;
      }
      await TTS.forceStopAndWait();
      announce("I didn't catch that. Let's try again.", false);
      await TTS.waitForFinish();
      await new Promise(r=>setTimeout(r,500));
      continue;
    }
    
    log("Destination recognized: " + transcript);
    const candidates = Object.keys(node_coords).filter(n => n !== currentLocation);
    const bestMatch = findBestLocationMatch(transcript, candidates);
    
    if (!bestMatch) { 
      await TTS.forceStopAndWait();
      announce("I couldn't find that location. Please say your destination again.", false);
      await TTS.waitForFinish();
      await new Promise(r=>setTimeout(r,500));
      continue; 
    }

    // Voice confirmation with proper timing
    let confirmAttempts = 0;
    while (confirmAttempts < 3) {
      confirmAttempts++;
      
      // CRITICAL FIX: Force stop all speech before confirmation
      await TTS.forceStopAndWait();
      
      announce(`Did you mean ${bestMatch}? Say yes or no.`, false);
      
      // Wait for TTS to finish completely
      await TTS.waitForFinish();
      
      // Additional safety delay
      await new Promise(r => setTimeout(r, 1000));
      
      interimBox.style.display = 'block';
      interimBox.textContent = "Listening for yes or no...";
      
      const conf = await startSpeechRecognition({
        lang:'en-US', 
        interim:false, 
        timeout:10000,
        onInterim: (t) => { interimBox.textContent = "Hearing: " + t; }
      });

      interimBox.textContent = '';
      interimBox.style.display = 'none';

      if (!conf) {
        await TTS.forceStopAndWait();
        announce("I didn't hear your response. Please say yes or no clearly.", false);
        await TTS.waitForFinish();
        await new Promise(r=>setTimeout(r,500));
        continue;
      }

      log("Confirmation recognition: " + conf);
      const verdict = interpretConfirmation(conf);

      if (verdict === 'yes') {
        await TTS.forceStopAndWait();
        announce(`Confirmed. Starting navigation to ${bestMatch}.`, true);
        start_navigation(bestMatch); 
        return;
      } else if (verdict === 'no') {
        await TTS.forceStopAndWait();
        announce("Okay, let's try again. Please say your destination.", true);
        await TTS.waitForFinish();
        await new Promise(r=>setTimeout(r,500));
        break; // Break inner loop to restart destination asking
      } else if (verdict === 'ambiguous') {
        await TTS.forceStopAndWait();
        announce("I heard mixed signals. Please say just 'yes' or 'no'.", false);
        await TTS.waitForFinish();
        await new Promise(r=>setTimeout(r,500));
        continue; 
      } else {
        await TTS.forceStopAndWait();
        announce("I didn't understand. Please say 'yes' to confirm or 'no' to try again.", false);
        await TTS.waitForFinish();
        await new Promise(r=>setTimeout(r,500));
        continue;
      }
    }
    
    // If confirmation failed 3 times, restart destination input
    if (confirmAttempts >= 3) {
      await TTS.forceStopAndWait();
      announce("Voice confirmation failed. Let's try selecting your destination again.", false);
      await TTS.waitForFinish();
      await new Promise(r=>setTimeout(r,500));
    }
  }
  
  await TTS.forceStopAndWait();
  announce("Voice input failed repeatedly. Please type destination instead.", false);
  show_destination_modal();
}

/* ---------------------------
   Navigation Pathfinding
   --------------------------- */
function dijkstra(gr, start, end) {
  const pq = new MinHeap();
  pq.push({cost:0,node:start,path:[]});
  const visited = new Set();
  
  while (!pq.empty()) {
    const item = pq.pop();
    const {cost, node, path} = item;
    if (visited.has(node)) continue;
    
    const newPath = path.concat([node]);
    visited.add(node);
    
    if (node === end) return {path:newPath, cost};
    
    const neighbors = gr[node] || {};
    for (const nb in neighbors) {
      if (!visited.has(nb)) {
        pq.push({cost: cost + neighbors[nb], node: nb, path: newPath});
      }
    }
  }
  return {path:[], cost: Infinity};
}

class MinHeap {
  constructor(){ this.a = []; }
  push(x){ this.a.push(x); this._siftUp(); }
  pop(){ 
    if(this.a.length===0) return null; 
    const r=this.a[0]; 
    const last=this.a.pop(); 
    if(this.a.length) { 
      this.a[0]=last; 
      this._siftDown(); 
    } 
    return r; 
  }
  empty(){ return this.a.length===0; }
  _siftUp(){ 
    let i=this.a.length-1; 
    while(i>0){ 
      let p=Math.floor((i-1)/2); 
      if(this.a[p].cost<=this.a[i].cost) break; 
      [this.a[p],this.a[i]]=[this.a[i],this.a[p]]; 
      i=p; 
    } 
  }
  _siftDown(){ 
    let i=0; 
    const n=this.a.length; 
    while(true){ 
      let l=i*2+1; 
      let r=i*2+2; 
      let smallest=i; 
      if(l<n && this.a[l].cost < this.a[smallest].cost) smallest=l; 
      if(r<n && this.a[r].cost < this.a[smallest].cost) smallest=r; 
      if(smallest===i) break; 
      [this.a[i],this.a[smallest]]=[this.a[smallest],this.a[i]]; 
      i=smallest; 
    } 
  }
}

// Direction calculation helpers
function get_turn_direction(p1,p2,p3) {
  const v1 = [p2[0]-p1[0], p2[1]-p1[1]];
  const v2 = [p3[0]-p2[0], p3[1]-p2[1]];
  const raw = (Math.atan2(v2[1], v2[0]) - Math.atan2(v1[1], v1[0])) * 180/Math.PI;
  const angle = (raw + 360) % 360;
  
  if (angle < 45 || angle > 315) return "Continue straight";
  if (angle >= 45 && angle < 135) return "Turn right";
  if (angle >= 135 && angle < 225) return "Turn around";
  return "Turn left";
}

function get_initial_direction_simple(p1,p2) {
  const dx = p2[0]-p1[0], dy = p2[1]-p1[1];
  const angle = (Math.atan2(dy,dx) * 180/Math.PI + 360) % 360;
  
  if (angle >= 315 || angle < 45) return "Go straight";
  if (angle >= 45 && angle < 135) return "Turn right";
  if (angle >= 135 && angle < 225) return "Turn around";
  return "Turn left";
}

/* ---------------------------
   Navigation Progress UI
   --------------------------- */
function updateNavigationProgressUI() {
  if (!navigationState.active) {
    navigationProgress.style.display = 'none';
    return;
  }
  
  navigationProgress.style.display = 'block';
  navStepsList.innerHTML = '';
  
  const path = navigationState.fullPath;
  for (let i = 0; i < path.length; i++) {
    const stepDiv = document.createElement('div');
    stepDiv.className = 'nav-step';
    
    if (i < navigationState.currentStepIndex) {
      stepDiv.classList.add('completed');
      stepDiv.textContent = `✓ ${path[i]}`;
    } else if (i === navigationState.currentStepIndex) {
      stepDiv.classList.add('current');
      stepDiv.textContent = `→ ${path[i]} (Current)`;
    } else {
      stepDiv.textContent = `${i + 1}. ${path[i]}`;
    }
    
    navStepsList.appendChild(stepDiv);
  }
}

/* ---------------------------
   Main Navigation Functions
   --------------------------- */
function start_navigation(destination) {
  if (!currentLocation) { 
    announce("No current location. Scan QR codes first.", false); 
    return; 
  }
  
  if (!destination) { 
    announce("No destination selected.", false); 
    return; 
  }
  
  const res = dijkstra(graph, currentLocation, destination);
  if (!res.path.length || res.cost === Infinity) { 
    announce("No path found to that destination.", false); 
    alert("Routing error: no path found."); 
    return; 
  }
  
  // Initialize navigation state
  navigationState.active = true;
  navigationState.fullPath = res.path;
  navigationState.currentStepIndex = 0;
  navigationState.waitingForQR = false;
  navigationState.expectedLocation = null;
  navigationState.waitingForVoice = false;
  navigationState.skipCount = 0;
  navigationState.destination = destination;
  
  // Set for map highlighting
  destinationNode = destination;
  
  // Update UI
  updateNavigationProgressUI();
  drawMap();
  
  log(`🗺️ Navigation started from ${currentLocation} to ${destination}`);
  log(`📍 Full path: ${res.path.join(' → ')}`);
  log(`📏 Total distance: ${Math.round(res.cost)} meters`);
  
  announce(`Navigation started to ${destination}. Total distance ${Math.round(res.cost)} meters. You will pass through ${res.path.length - 2} waypoints.`, true);
  
  // Give first instruction after brief pause
  setTimeout(async () => {
    await TTS.waitForFinish();
    giveCurrentInstruction();
  }, 2000);
}

async function giveCurrentInstruction() {
  if (!navigationState.active) return;
  
  const path = navigationState.fullPath;
  const idx = navigationState.currentStepIndex;
  
  // Check if we've reached destination
  if (idx >= path.length - 1) {
    finishNavigation();
    return;
  }
  
  const current = path[idx];
  const next = path[idx + 1];
  const distance = (graph[current] && graph[current][next]) ? graph[current][next] : 0;
  const totalSteps = path.length - 1;
  const stepNum = idx + 1;
  
  let instruction;
  if (idx === 0) {
    // First step
    instruction = `From ${current}, ${get_initial_direction_simple(node_coords[current], node_coords[next])} towards ${next}`;
  } else {
    // Subsequent steps
    const prev = path[idx - 1];
    instruction = `At ${current}, ${get_turn_direction(node_coords[prev], node_coords[current], node_coords[next])} towards ${next}`;
  }
  
  const stepInfo = `Step ${stepNum} of ${totalSteps}. ${instruction}. Distance ${distance.toFixed(0)} meters.`;
  
  await TTS.forceStopAndWait();
  announce(stepInfo, true);
  log(`🗺️ Navigation Step ${stepNum}/${totalSteps}: ${instruction} (${distance.toFixed(0)}m)`);
  overlayText.textContent = `Step ${stepNum}/${totalSteps}: Walk to ${next}`;
  
  updateNavigationProgressUI();
  
  // Wait for instruction to finish, then wait for user voice command
  await TTS.waitForFinish();
  setTimeout(() => {
    waitForNextCommand(next);
  }, 1000);
}

async function waitForNextCommand(expectedNext) {
  if (!navigationState.active) return;
  
  navigationState.waitingForVoice = true;
  
  await TTS.forceStopAndWait();
  announce(`Say 'next' to continue to ${expectedNext}, or 'skip' to skip this waypoint, or 'cancel' to stop navigation.`, false);
  
  await TTS.waitForFinish();
  
  // Wait indefinitely for user response
  while (navigationState.active && navigationState.waitingForVoice) {
    // Additional safety delay before starting recognition
    await new Promise(r => setTimeout(r, 800));
    
    const interimBox = document.getElementById('listeningBox');
    interimBox.style.display = 'block';
    interimBox.textContent = "Listening for 'next', 'skip', or 'cancel'...";
    
    const response = await startSpeechRecognition({
      lang: 'en-US', 
      interim: true, 
      timeout: 30000,
      onInterim: (t) => { interimBox.textContent = "Listening... " + t; }
    });
    
    interimBox.textContent = '';
    interimBox.style.display = 'none';
    
    if (!response) {
      // Just quietly restart listening without nagging
      await new Promise(r => setTimeout(r, 2000));
      continue;
    }
    
    const command = response.toLowerCase().trim();
    log(`Navigation command heard: "${command}"`);
    
    if (command.includes('next') || command.includes('ready') || command.includes('continue') || command.includes('arrived')) {
      navigationState.waitingForVoice = false;
      startQRVerification(expectedNext);
      return;
    } else if (command.includes('skip')) {
      navigationState.waitingForVoice = false;
      handleSkipWaypoint();
      return;
    } else if (command.includes('cancel') || command.includes('stop') || command.includes('quit')) {
      cancelNavigation();
      return;
    } else if (command.includes('repeat') || command.includes('again')) {
      await giveCurrentInstruction();
      return;
    } else {
      // Brief feedback and continue listening
      const interimBox = document.getElementById('listeningBox');
      interimBox.style.display = 'block';
      interimBox.textContent = "Say 'next', 'skip', or 'cancel'...";
      await new Promise(r => setTimeout(r, 1500));
      continue;
    }
  }
}

async function handleSkipWaypoint() {
  if (!navigationState.active) return;
  
  navigationState.skipCount++;
  
  announce(`Skipping this waypoint. Proceeding to next step.`, false);
  log(`⏭️ Skipped waypoint: ${navigationState.fullPath[navigationState.currentStepIndex + 1]}`);
  
  // If too many skips, offer direct route to destination
  if (navigationState.skipCount >= 2) {
    await TTS.forceStopAndWait();
    announce(`You've skipped ${navigationState.skipCount} waypoints. Would you like me to direct you straight to the final destination? Say yes or no.`, false);
    
    await TTS.waitForFinish();
    await new Promise(r => setTimeout(r, 1000));
    
    const interimBox = document.getElementById('listeningBox');
    interimBox.style.display = 'block';
    interimBox.textContent = "Listening for yes or no...";
    
    const response = await startSpeechRecognition({
      lang: 'en-US', 
      interim: false, 
      timeout: 10000
    });
    
    interimBox.style.display = 'none';
    
    if (response && interpretConfirmation(response) === 'yes') {
      // Skip to final destination
      navigationState.currentStepIndex = navigationState.fullPath.length - 2;
      await TTS.forceStopAndWait();
      announce(`Redirecting you directly to ${navigationState.destination}.`, true);
      await TTS.waitForFinish();
      setTimeout(() => {
        giveCurrentInstruction();
      }, 1000);
      return;
    }
  }
  
  // Continue to next step
  navigationState.currentStepIndex++;
  updateNavigationProgressUI();
  
  setTimeout(() => {
    giveCurrentInstruction();
  }, 1000);
}

function startQRVerification(expectedLocation) {
  if (!navigationState.active) return;
  
  navigationState.waitingForQR = true;
  navigationState.expectedLocation = expectedLocation;
  
  TTS.forceStopAndWait().then(() => {
    announce(`Please scan the QR code at ${expectedLocation} to verify your location.`, true);
    overlayText.textContent = `Scan QR at ${expectedLocation} to continue`;
    
    // Start camera if not running
    if (!scannerRunning) {
      log("🎥 Starting camera for QR verification...");
      setTimeout(() => {
        startCamera();
      }, 1500);
    }
  });
}

function handleNavigationQRScan(scannedLocation) {
  if (!navigationState.active || !navigationState.waitingForQR) return false;

  const expected = navigationState.expectedLocation;
  const scanned = scannedLocation.trim();

  log(`🔍 QR Verification: Expected "${expected}", Scanned "${scanned}"`);

  if (scanned === expected || scanned.toLowerCase() === expected.toLowerCase()) {
    // ✅ Correct location scanned (step by step)
    TTS.stop();
    announce(`Verified: You are at ${scanned}.`, true);

    navigationState.waitingForQR = false;
    navigationState.currentStepIndex++;
    currentLocation = scanned;

    stopCamera();
    updateNavigationProgressUI();

    // Check if this was the last step
    if (navigationState.currentStepIndex >= navigationState.fullPath.length) {
      finishNavigation();
    } else {
      // Continue to next step
      setTimeout(async () => {
        await TTS.waitForFinish();
        giveCurrentInstruction();
      }, 2000);
    }

    return true;
  } else {
    // ❌ Wrong or skipped location
    const pathIndex = navigationState.fullPath.indexOf(scanned);

    if (pathIndex !== -1 && pathIndex > navigationState.currentStepIndex) {
  const skippedCount = pathIndex - navigationState.currentStepIndex;
  const skippedLocations = navigationState.fullPath.slice(navigationState.currentStepIndex, pathIndex);

  // ✅ Stop any existing TTS/instructions to avoid duplicate announcements
  TTS.forceStopAndWait().then(() => {
    if (skippedCount > 0) {
      announce(`You are at ${scanned}. You skipped ${skippedCount} waypoint${skippedCount > 1 ? 's' : ''}: ${skippedLocations.join(', ')}.`, true);
    } else {
      announce(`You are at ${scanned}. Continuing navigation from here.`, true);
    }

    navigationState.currentStepIndex = pathIndex;
    currentLocation = scanned;
    navigationState.waitingForQR = false;

    stopCamera();
    updateNavigationProgressUI();

    if (navigationState.currentStepIndex >= navigationState.fullPath.length - 1) {
      finishNavigation();
    } else {
      // ✅ Only trigger next instruction *once* after skip announcement is done
      setTimeout(async () => {
        await TTS.waitForFinish();
        if (!navigationState.waitingForQR) { // prevent duplicate calls
          giveCurrentInstruction();
        }
      }, 500); // shorter delay, smoother transition
    }
  });

  return true;

    } else if (pathIndex !== -1 && pathIndex < navigationState.currentStepIndex) {
      // ⬅️ User scanned a location already passed
      announce(`This is ${scanned}, but you've already passed this point. Please continue to ${expected}, or say 'skip' to skip this waypoint.`, false);
      return false;
    } else {
      // 🚫 Location not on path
      announce(`This is ${scanned}, but I expected ${expected}. Please find ${expected} and scan it, or say 'skip' to skip this waypoint.`, false);
      return false;
    }
  }
}

function finishNavigation() {
  const finalDestination = navigationState.fullPath[navigationState.fullPath.length - 1];
  
  navigationState.active = false;
  navigationState.waitingForQR = false;
  navigationState.waitingForVoice = false;
  
  // Update UI
  navigationProgress.style.display = 'none';
  destinationNode = null;
  drawMap();
  
  TTS.stop();
  announce(`Congratulations! You have successfully arrived at your destination: ${finalDestination}. Navigation complete!`, true);
  overlayText.textContent = `🎯 Arrived at ${finalDestination} - Navigation Complete!`;
  
  log(`🎯 Navigation completed successfully to ${finalDestination}`);
  if (navigationState.skipCount > 0) {
    log(`📊 Navigation stats: ${navigationState.skipCount} waypoints were skipped`);
  }
  
  // Vibrate arrival pattern
  vibrateArrival();
  
  setTimeout(() => {
    announce("You can start a new navigation by pressing the Voice Destination button.", false);
  }, 3000);
}

function cancelNavigation() {
  navigationState.active = false;
  navigationState.waitingForQR = false;
  navigationState.waitingForVoice = false;
  destinationNode = null;
  
  // Update UI
  navigationProgress.style.display = 'none';
  drawMap();
  
  TTS.forceStopAndWait().then(() => {
    announce("Navigation cancelled.", true);
    overlayText.textContent = "Navigation cancelled";
    log("❌ Navigation cancelled by user");
    
    if (scannerRunning) {
      stopCamera();
    }
  });
}

/* ---------------------------
   UI Event Handlers
   --------------------------- */
startBtn.onclick = async () => { 
  if (scannerRunning) { 
    announce("Scanner already running.", false); 
    return; 
  } 
  userGesturePerformed = true; 
  await startCamera(); 
};

stopBtn.onclick = () => { 
  stopCamera(); 
  if (navigationState.active) {
    cancelNavigation();
  }
};

restartBtn.onclick = () => { 
  if (navigationState.active) {
    cancelNavigation();
  }
  stopCamera(); 
  foundResults.clear(); 
  actionsTriggered=false; 
  scanStartTime = Date.now(); 
  setTimeout(()=>{ startBtn.click(); },300); 
};

voiceDestBtn.onclick = async () => { 
  userGesturePerformed = true;
  
  // Check prerequisites
  if (!actionsTriggered) {
    announce("Please scan all three QR codes first to set up the system.", false);
    return;
  }
  
  if (!currentLocation) {
    announce("No current location detected. Please scan QR codes first.", false);
    return;
  }
  
  if (!SR_AVAILABLE) {
    announce("Speech recognition is not available in your browser. Using text input instead.", false);
    show_destination_modal();
    return;
  }
  
  // Disable button temporarily to prevent multiple clicks
  voiceDestBtn.disabled = true;
  voiceDestBtn.textContent = "Listening...";
  
  try {
    await ask_destination_via_voice();
  } catch (error) {
    console.error("Voice destination error:", error);
    announce("Voice input failed. Please try again.", false);
  } finally {
    // Re-enable button
    voiceDestBtn.disabled = false;
    voiceDestBtn.textContent = "Voice Destination";
  }
};

mapBtn.onclick = () => { 
  drawMap(); 
  mapModal.style.display = 'flex'; 
  announce("Map opened. Close when ready.", false); 
};

closeMap.onclick = () => { 
  mapModal.style.display = 'none'; 
  announce("Map closed.", false); 
};

// Keyboard shortcuts
window.addEventListener('keydown', (e) => {
  if (e.key === 's' || e.key === 'S') { startBtn.click(); }
  if (e.key === 'v' || e.key === 'V') { voiceDestBtn.click(); }
  if (e.key === 'm' || e.key === 'M') { mapBtn.click(); }
  if (e.key === 'r' || e.key === 'R') { restartBtn.click(); }
  if (e.code === 'Space') { e.preventDefault(); stopBtn.click(); }
});

/* ---------------------------
   OpenCV Initialization
   --------------------------- */
function onOpenCvReady(){ 
  cvReady = true; 
  log("OpenCV ready"); 
  announce("OpenCV loaded - improved color detection available.", false); 
}

if (typeof cv !== 'undefined') {
  if (cv && cv.Mat) onOpenCvReady();
  else cv['onRuntimeInitialized'] = onOpenCvReady;
} else {
  setTimeout(()=>{ 
    if (!cvReady) announce("OpenCV not loaded. Using JavaScript color detection.", false); 
  }, 7000);
}

// Cleanup on page unload
window.addEventListener('beforeunload', ()=>{ 
  if (stream) stream.getTracks().forEach(t=>t.stop()); 
  speechSynthesis.cancel(); 
});

// Initialize application
announce("VI Indoor Navigation System ready. Start by scanning the initial QR codes to determine your location.", false);
log("App initialized. Speech recognition available: " + (SR_AVAILABLE ? 'yes' : 'no'));
log("Enhanced step-by-step navigation with QR verification enabled");
</script>
</body>
</html>
