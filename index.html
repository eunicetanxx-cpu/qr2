<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VI-Friendly Indoor Navigation</title>
  <style>
    :root{
      --bg:#000; --card:#0b1220; --accent:#ffd54f; --accent-2:#00e676; --text:#fff;
      --muted:#9aa8b2;
      --btn-h:64px; --btn-font:20px;
    }
    html,body{height:100%; margin:0; background:linear-gradient(180deg,#05070a 0%, #0b0f14 100%); color:var(--text); font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; -webkit-font-smoothing:antialiased;}
    .app {
      max-width: 980px;
      margin: 12px auto;
      padding: 18px;
      padding-bottom: 200px;
      background: linear-gradient(180deg, #071018 0, #07121a 100%);
      border-radius: 14px;
      box-shadow: 0 8px 36px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.02);
    }
    header { display:flex; gap:12px; align-items:center; }
    h1 { font-size:24px; margin:0; color:var(--accent); letter-spacing:0.6px; }
    .subtitle { color: var(--muted); font-size:14px; margin-top:4px; }

    .controls { margin:14px 0; display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .btn { background:var(--accent); color:#000; border:none; padding:12px 18px; border-radius:12px; font-size:var(--btn-font); height:var(--btn-h); min-width:150px; cursor:pointer; box-shadow:0 8px 18px rgba(0,0,0,0.5); }
    .btn.secondary { background:transparent; color:var(--text); border:2px solid rgba(255,255,255,0.06); }
    .btn.ghost { background:transparent; color:var(--accent); border:2px dashed rgba(255,213,79,0.18); }
    .btn:focus { outline:4px solid rgba(255,213,79,0.25); outline-offset:3px; }
    .select { font-size:18px; padding:12px; border-radius:12px; height:var(--btn-h); background:#07141a; color:var(--text); border:1px solid rgba(255,255,255,0.03); min-width:140px; }
    .btn.green { background:#4caf50; color:#fff; }
    .btn.red { background:#f44336; color:#fff; }
    .btn.yellow { background:#ffeb3b; color:#000; }
    .btn.grey { background:#9e9e9e; color:#fff; }

    .main-controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #071018;
      padding: 14px;
      display: flex;
      justify-content: center;
      gap: 12px;
      z-index: 1000;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.6);
    }

    .statusBox { margin-top:12px; padding:14px; background:linear-gradient(180deg,#071018,#06121a); border-radius:12px; border:1px solid rgba(0,255,136,0.03); min-height:100px; display:flex; gap:12px; align-items:flex-start; }
    #leftStatus { flex:1; }
    #overlayText { font-weight:800; font-size:20px; color:var(--text); margin-bottom:6px; }
    #srAnnounce { font-size:17px; color:var(--muted); margin-top:6px; }
    #listeningBox { margin-top:10px; font-size:18px; color:#ffb74d; min-height:22px; }

    #previewWrap { display:flex; gap:12px; margin-top:14px; align-items:flex-start; justify-content:center; }
    #previewCanvas {
      width: 100%;
      max-width: 800px;
      height: auto;
      background: #000;
      border-radius: 10px;
      border: 2px solid #0b1b2a;
      object-fit: cover;
      display:block;
      margin: 0 auto;
    }

    .alerts { padding:12px; border-radius:10px; background:#061217; border:1px solid rgba(255,255,255,0.02); min-height:100px; color:var(--muted); }
    .alerts h4 { margin:0 0 6px 0; color:var(--accent); font-size:16px; }
    .alerts ul { margin:0; padding-left:18px; font-size:16px; color:var(--muted); }
    .alerts li { margin-bottom:6px; }

    #log { margin-top:12px; background:#02060a; color:#b8d3de; padding:12px; border-radius:10px; height:160px; overflow:auto; font-size:14px; border:1px solid rgba(255,255,255,0.02); }

    .cancel-overlay {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1001;
      display: none;
    }

    footer { margin-top:14px; color:var(--muted); font-size:13px; text-align:center; }

    .visually-hidden { position:absolute !important; height:1px; width:1px; overflow:hidden; clip:rect(1px,1px,1px,1px); white-space:nowrap; }
    @media (max-width:760px){
      #previewCanvas { width:100%; height:260px; }
      .controls { gap:8px; }
      .btn { min-width:120px; font-size:18px; height:56px; }
    }
  </style>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
</head>
<body>
  <div class="app" role="application" aria-labelledby="appTitle">
    <header>
      <div>
        <h1 id="appTitle">VI Indoor Navigation</h1>
        <div class="subtitle">QR-based navigation with voice guidance</div>
      </div>
    </header>

   <div class="controls" role="region" aria-label="Settings">
    <label style="display:flex; align-items:center; gap:8px; margin-left:6px; color:var(--muted); font-size:16px;">
      <input type="checkbox" id="enableDetect" checked aria-label="Enable object detection"> Enable Object Detection
    </label>
   </div>

   <div class="statusBox" role="status" aria-live="polite">
    <div id="leftStatus">
      <div id="overlayText">Ready — Start to begin scanning for QR codes.</div>
      <div id="srAnnounce" aria-live="polite" role="log">Status messages will be read aloud.</div>
      <div id="listeningBox" aria-hidden="true"></div>
    </div>

    <div id="alertsPanel">
      <div class="alerts" aria-live="polite">
        <h4>Object Alerts</h4>
        <ul id="alertsList"><li>No recent alerts</li></ul>
      </div>
    </div>
   </div>

   <div id="previewWrap">
     <canvas id="previewCanvas" width="800" height="600" aria-label="Camera preview"></canvas>
   </div>

   <div id="log" aria-live="polite" role="log"></div>

   <div class="main-controls" role="region" aria-label="Main controls">
       <button id="startBtn" class="btn green" aria-pressed="false" aria-label="Start navigation">Start Navigation</button>
   </div>

   <!-- Cancel button overlay (only shown during navigation) -->
   <div class="cancel-overlay" id="cancelOverlay">
     <button id="cancelBtn" class="btn red" aria-label="Cancel navigation">Cancel Navigation</button>
   </div>

   <footer>Built for visually impaired users — voice guidance and object detection for safe navigation.</footer>
  </div>

<script>
/* ---------------------------
   DOM elements and helpers
   --------------------------- */
const overlayText = document.getElementById('overlayText');
const srAnnounce = document.getElementById('srAnnounce');
const previewCanvas = document.getElementById('previewCanvas');
const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
const canvasDisp = document.createElement('canvas');
const ctxDisp = canvasDisp.getContext('2d', { willReadFrequently: true });
const logEl = document.getElementById('log');
const startBtn = document.getElementById('startBtn');
const cancelBtn = document.getElementById('cancelBtn');
const cancelOverlay = document.getElementById('cancelOverlay');
const enableDetectCheckbox = document.getElementById('enableDetect');
const alertsList = document.getElementById('alertsList');

const log = (m) => { 
  console.log(m); 
  const t = new Date().toLocaleTimeString(); 
  logEl.innerText += `[${t}] ${m}\n`; 
  logEl.scrollTop = logEl.scrollHeight; 
};

/* ---------------------------
   State variables
   --------------------------- */
let cvReady = false;
let animationFrameId = null;
let stream = null;
let scannerRunning = false;
let currentLocation = null;
let finalDestination = null;
let isNavigating = false;
let userGesturePerformed = false;

// Object detection
let cocoModel = null;
let cocoReady = false;
const DETECTION_INTERVAL_MS = 900;
const SCORE_THRESHOLD = 0.45;
const CENTER_TOLERANCE = 0.25;
const DISTANCE_ESTIMATE_SCALE = 1.6;
let lastDetectTime = 0;
let latestDetections = [];
const alertCooldown = 3000;
const lastAlertAt = {};
const HARMFUL_CLASSES = new Set(['person','chair','couch','bench','dining table','stop sign','tv','suitcase','backpack','bed','toilet']);

/* ---------------------------
   Navigation graph (same as before)
   --------------------------- */
const node_coords = {
  "Female Toilet (NGT1)": [2009, 1357],
  "Male Toilet (NGT2)": [1955, 1357],
  "N001 (backdoor)": [2100, 1135],
  "N001": [1907, 1121],
  "N002": [1651, 1097],
  "N003": [1387, 1074],
  "N004": [892, 1097],
  "N005": [638, 1115],
  "N006": [383, 1139],
  "N007": [127, 1158],
  "N008": [4, 1330],
  "Female Toilet (NGT5)": [357, 1350],
  "Male Toilet (NGT4)": [403, 1351],
  "N009": [492, 1330],
  "N010": [822, 1335],
  "N011": [1251, 1340],
  "N012": [1597, 1340],
};

const graph_raw = {
  "Female Toilet (NGT1)": {"Male Toilet (NGT2)": 1.89},
  "N001": {"Female Toilet (NGT1)": 9.00, "N001 (backdoor)": 6.77, "N002": 9.00},
  "N002": {"N003": 9.28},
  "N003": {"N004": 17.35},
  "N004": {"N005": 8.91},
  "N005": {"N006": 8.97},
  "N006": {"Male Toilet (NGT4)": 7.45, "Female Toilet (NGT5)": 7.44, "N007": 8.99},
  "N007": {"N008": 7.40},
  "N008": {"Female Toilet (NGT5)": 12.38},
  "Female Toilet (NGT5)": {"Male Toilet (NGT4)": 1.61},
  "Male Toilet (NGT4)": {"N009": 3.20},
  "N009": {"N010": 11.55},
  "N010": {"N011": 15.02},
  "N011": {"N012": 12.11},
  "N012": {"Male Toilet (NGT2)": 12.55}
};

function add_bidirectional_edges(graph_in) {
  const new_graph = {};
  for (const k in graph_in) new_graph[k] = {};
  for (const from in graph_in) {
    for (const to in graph_in[from]) {
      const w = graph_in[from][to];
      new_graph[from][to] = w;
      if (!new_graph[to]) new_graph[to] = {};
      new_graph[to][from] = w;
    }
  }
  return new_graph;
}

const graph = add_bidirectional_edges(graph_raw);

/* ---------------------------
   TTS Queue
   --------------------------- */
const TTS = {
  queue: [], 
  speaking: false,
  speak(text, interrupt=false) {
    if(!text) return;
    if(interrupt){ 
      this.queue=[]; 
      if (speechSynthesis.speaking) speechSynthesis.cancel(); 
    }
    this.queue.push(text); 
    this._maybeSpeak();
  },
  _maybeSpeak() {
    if(this.speaking) return;
    const next = this.queue.shift();
    if(!next) return;
    this.speaking = true;
    const utt = new SpeechSynthesisUtterance(next); 
    utt.rate = 1.0;
    utt.onend = () => { 
      this.speaking = false; 
      setTimeout(()=>this._maybeSpeak(), 80); 
    };
    utt.onerror = () => { 
      this.speaking = false; 
      setTimeout(()=>this._maybeSpeak(), 80); 
    };
    speechSynthesis.speak(utt);
  }
};

function announce(text, interrupt=false) {
  overlayText.textContent = text;
  srAnnounce.textContent = text;
  TTS.speak(text, interrupt);
  log(`[ANNOUNCE] ${text}`);
}

/* ---------------------------
   Speech Recognition
   --------------------------- */
let SR_AVAILABLE = false;
try { 
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 
  if (SpeechRecognition) SR_AVAILABLE = true; 
} catch(e){ 
  SR_AVAILABLE=false; 
}

function startSpeechRecognition({lang='en-US', interim=true, timeout=15000, onInterim=null} = {}) {
  return new Promise((resolve) => {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) { resolve(null); return; }
    
    let recognition;
    try { recognition = new SR(); } catch(e) { resolve(null); return; }
    
    recognition.lang = lang; 
    recognition.interimResults = interim; 
    recognition.maxAlternatives = 3;
    
    let finalTranscript = '';
    let resolved = false;
    
    const timer = setTimeout(() => {
      if (!resolved) { 
        resolved = true; 
        try { recognition.stop(); } catch(e){}; 
        resolve(null); 
      }
    }, timeout);
    
    recognition.onresult = (evt) => {
      const results = Array.from(evt.results);
      const interimText = results.map(r => r[0].transcript).join(' ');
      if (onInterim) onInterim(interimText);
      
      for (const r of results) { 
        if (r.isFinal) finalTranscript = r[0].transcript; 
      }
      
      if (finalTranscript && !resolved) { 
        resolved = true; 
        clearTimeout(timer); 
        try { recognition.stop(); } catch(e){}; 
        resolve(finalTranscript.trim()); 
      }
    };
    
    recognition.onend = () => {
      if (resolved) return;
      resolved = true; 
      clearTimeout(timer); 
      resolve(finalTranscript ? finalTranscript.trim() : null);
    };
    
    recognition.onerror = (e) => {
      if (resolved) return;
      resolved = true; 
      clearTimeout(timer); 
      try { recognition.stop(); } catch(err){}; 
      resolve(null);
    };
    
    try { recognition.start(); } catch(e) { clearTimeout(timer); resolve(null); }
  });
}

/* ---------------------------
   QR Code Detection (simplified - any QR)
   --------------------------- */
function detectQRInFrame(imageData) {
  try {
    // Try standard detection first
    const code = jsQR(imageData.data, imageData.width, imageData.height, { 
      inversionAttempts: 'attemptBoth' 
    });
    
    if (code && code.data) {
      return {
        found: true,
        decoded: code.data.trim(),
        location: code.location || null
      };
    }
    
    return { found: false };
  } catch(e) {
    console.warn('QR detection error:', e);
    return { found: false };
  }
}

/* ---------------------------
   Camera and processing
   --------------------------- */
async function startCamera() {
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { 
        facingMode: "environment", 
        width: { ideal: 1280 }, 
        height: { ideal: 720 } 
      }, 
      audio: false
    });
    
    const video = document.createElement('video');
    video.autoplay = true; 
    video.playsInline = true; 
    video.muted = true;
    video.srcObject = stream;
    await video.play();

    canvasDisp.width = video.videoWidth || 1280;
    canvasDisp.height = video.videoHeight || 720;
    previewCanvas.width = Math.min(800, canvasDisp.width);
    previewCanvas.height = Math.min(600, canvasDisp.height);

    scannerRunning = true;
    processFrame(video);
    userGesturePerformed = true;
    return true;
  } catch(e) {
    announce("Camera access denied or unavailable. Check permissions and try again.", true);
    log("Camera error: " + e);
    return false;
  }
}

function stopCamera() {
  if (stream) stream.getTracks().forEach(t => t.stop());
  if (animationFrameId) { 
    cancelAnimationFrame(animationFrameId); 
    animationFrameId = null; 
  }
  scannerRunning = false;
  log("Camera stopped.");
}

/* ---------------------------
   Load COCO model
   --------------------------- */
async function loadCocoModel() {
  try {
    log("Loading coco-ssd...");
    cocoModel = await cocoSsd.load();
    cocoReady = true;
    log("coco-ssd loaded");
  } catch(e) {
    cocoReady = false;
    log("coco load failed: " + e);
  }
}
loadCocoModel();

/* ---------------------------
   Frame processing
   --------------------------- */
let qrDecoderBusy = false;
let frameSkipCounter = 0;

async function processFrame(video) {
  if (!scannerRunning) return;
  animationFrameId = requestAnimationFrame(() => processFrame(video));
  if (!video || video.readyState < 2) return;

  frameSkipCounter++;
  if (frameSkipCounter % 2 !== 0) return; // Process every other frame

  // Ensure canvas sizes
  canvasDisp.width = video.videoWidth || canvasDisp.width;
  canvasDisp.height = video.videoHeight || canvasDisp.height;

  // Draw frame
  ctxDisp.drawImage(video, 0, 0, canvasDisp.width, canvasDisp.height);
  
  // Update preview
  drawPreviewFrame();

  // QR detection (non-blocking)
  if (!qrDecoderBusy) {
    qrDecoderBusy = true;
    setTimeout(async () => {
      try {
        // Use full frame for QR detection
        const imageData = ctxDisp.getImageData(0, 0, canvasDisp.width, canvasDisp.height);
        const detection = detectQRInFrame(imageData);
        
        if (detection.found && detection.decoded) {
          handleQRDetected(detection.decoded, detection.location);
        }
      } catch(e) {
        console.error("QR processing error:", e);
      } finally {
        qrDecoderBusy = false;
      }
    }, 16);
  }

  // Object detection (only if navigation is active)
  if (isNavigating && enableDetectCheckbox.checked && cocoReady) {
    const now = performance.now();
    if (now - lastDetectTime > DETECTION_INTERVAL_MS) {
      lastDetectTime = now;
      performObjectDetection();
    }
  }
}

function drawPreviewFrame() {
  try {
    const sx = previewCanvas.width / canvasDisp.width;
    const sy = previewCanvas.height / canvasDisp.height;
    
    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
    previewCtx.drawImage(canvasDisp, 0, 0, previewCanvas.width, previewCanvas.height);

    // Draw object detection overlays
    if (latestDetections && latestDetections.length && enableDetectCheckbox.checked) {
      previewCtx.save();
      previewCtx.lineWidth = Math.max(2, Math.round(previewCanvas.width * 0.004));
      
      for (const d of latestDetections) {
        const [x, y, w, h] = d.bbox;
        const rx = Math.round(x * sx);
        const ry = Math.round(y * sy);
        const rw = Math.round(w * sx);
        const rh = Math.round(h * sy);
        
        previewCtx.strokeStyle = 'rgba(255,80,80,0.95)';
        previewCtx.fillStyle = 'rgba(255,80,80,0.85)';
        previewCtx.strokeRect(rx, ry, rw, rh);
        
        const label = `${d.class} ${(d.score*100).toFixed(0)}%`;
        previewCtx.font = '14px Arial';
        const tw = previewCtx.measureText(label).width + 10;
        previewCtx.fillRect(rx, Math.max(ry-22, 0), tw, 20);
        previewCtx.fillStyle = '#fff';
        previewCtx.fillText(label, rx+5, Math.max(ry-8, 12));
        previewCtx.fillStyle = 'rgba(255,80,80,0.85)';
      }
      previewCtx.restore();
    }
  } catch(e) { 
    console.warn("drawPreviewFrame error", e); 
  }
}

async function performObjectDetection() {
  try {
    // Create smaller canvas for detection
    const off = document.createElement('canvas');
    const D_W = 480;
    const scale = D_W / canvasDisp.width;
    off.width = D_W;
    off.height = Math.floor(canvasDisp.height * scale);
    const offCtx = off.getContext('2d');
    offCtx.drawImage(canvasDisp, 0, 0, off.width, off.height);
    
    const predictions = await cocoModel.detect(off);
    const preds = predictions.filter(p => p.score >= SCORE_THRESHOLD);
    const scaleBack = canvasDisp.width / off.width;
    
    latestDetections = preds.map(p => {
      const [x, y, w, h] = p.bbox;
      return { 
        class: p.class, 
        score: p.score, 
        bbox: [x*scaleBack, y*scaleBack, w*scaleBack, h*scaleBack] 
      };
    });

    updateAlertsList(latestDetections.slice(0, 4));
    
    // Check for obstacles ahead
    checkForObstacles();
    
  } catch(e) {
    console.warn("Object detection error", e);
  }
}

function checkForObstacles() {
  let candidate = null;
  const fh = canvasDisp.height;
  const fw = canvasDisp.width;
  
  for (const det of latestDetections) {
    if (!HARMFUL_CLASSES.has(det.class)) continue;
    
    const [x, y, w, h] = det.bbox;
    const cx = x + w/2;
    const centerDelta = Math.abs(cx - fw/2) / fw;
    const score = (h / fh) * (1.0 - Math.min(centerDelta / 0.5, 1.0));
    
    if (!candidate || score > candidate.score) {
      candidate = {det, score};
    }
  }
  
  if (candidate) {
    const det = candidate.det;
    const [x, y, w, h] = det.bbox;
    const cx = x + w/2;
    const centerDelta = Math.abs(cx - fw/2) / fw;
    const isAhead = (centerDelta <= CENTER_TOLERANCE) && (h / fh >= 0.06);
    
    if (isAhead) {
      const cls = det.class;
      const nowTs = Date.now();
      
      if (!lastAlertAt[cls] || (nowTs - lastAlertAt[cls] > alertCooldown)) {
        const ratio = (h / fh);
        let distMeters = (DISTANCE_ESTIMATE_SCALE / Math.max(ratio, 0.02));
        distMeters = Math.min(Math.max(distMeters, 0.2), 50.0);
        
        if (distMeters <= 5.0) {
          announce(`Obstacle ahead: ${cls}, approximately ${distMeters.toFixed(1)} meters.`, false);
          lastAlertAt[cls] = nowTs;
          log(`[OBSTACLE] ${cls} @ ${distMeters.toFixed(1)}m`);
        }
      }
    }
  }
}

function updateAlertsList(dets) {
  alertsList.innerHTML = '';
  for (const d of dets) {
    const li = document.createElement('li');
    li.textContent = `${d.class} ${(d.score*100).toFixed(0)}%`;
    alertsList.appendChild(li);
  }
  if (dets.length === 0) {
    const li = document.createElement('li'); 
    li.textContent = 'No recent alerts'; 
    alertsList.appendChild(li);
  }
}

/* ---------------------------
   QR Detection with guidance
   --------------------------- */
function handleQRDetected(qrData, location) {
  const cleanData = qrData.trim();
  log(`QR detected: ${cleanData}`);
  
  if (!currentLocation) {
    // First QR scan - set as current location
    currentLocation = cleanData;
    announce(`Location detected: ${cleanData}. Please move closer to the QR code to scan it properly.`, true);
    
    // Give guidance to center the QR code
    if (location && location.topLeftCorner && location.bottomRightCorner) {
      provideQRGuidance(location);
    }
    
    // After a brief pause, check if user wants to scan
    setTimeout(() => {
      checkQRScanCompletion(cleanData, location);
    }, 2000);
    
  } else if (isNavigating) {
    // During navigation - update current location
    currentLocation = cleanData;
    
    if (cleanData === finalDestination) {
      // Reached destination!
      handleDestinationReached();
    } else {
      // Intermediate location during navigation
      handleNavigationProgress(cleanData);
    }
  }
}

function provideQRGuidance(location) {
  if (!location || !location.topLeftCorner || !location.bottomRightCorner) return;
  
  const frameW = canvasDisp.width;
  const frameH = canvasDisp.height;
  const centerX = frameW / 2;
  const centerY = frameH / 2;
  
  // Calculate QR code center
  const qrCenterX = (location.topLeftCorner.x + location.bottomRightCorner.x) / 2;
  const qrCenterY = (location.topLeftCorner.y + location.bottomRightCorner.y) / 2;
  
  // Calculate QR code size
  const qrWidth = Math.abs(location.bottomRightCorner.x - location.topLeftCorner.x);
  const qrHeight = Math.abs(location.bottomRightCorner.y - location.topLeftCorner.y);
  const qrSize = Math.min(qrWidth, qrHeight);
  
  // Check if QR is centered and large enough
  const deltaX = qrCenterX - centerX;
  const deltaY = qrCenterY - centerY;
  const tolerance = Math.min(frameW, frameH) * 0.1; // 10% tolerance
  const minSize = Math.min(frameW, frameH) * 0.15; // Minimum 15% of frame
  
  let guidance = [];
  
  if (Math.abs(deltaX) > tolerance) {
    if (deltaX > 0) {
      guidance.push("move left");
    } else {
      guidance.push("move right");
    }
  }
  
  if (Math.abs(deltaY) > tolerance) {
    if (deltaY > 0) {
      guidance.push("move up");
    } else {
      guidance.push("move down");
    }
  }
  
  if (qrSize < minSize) {
    guidance.push("move closer");
  } else if (qrSize > minSize * 2) {
    guidance.push("move back");
  }
  
  if (guidance.length > 0) {
    const instruction = "To scan properly: " + guidance.join(", ");
    announce(instruction, false);
  }
}

function checkQRScanCompletion(qrData, location) {
  // Check if QR is well-positioned for scanning
  if (location && location.topLeftCorner && location.bottomRightCorner) {
    const frameW = canvasDisp.width;
    const frameH = canvasDisp.height;
    const centerX = frameW / 2;
    const centerY = frameH / 2;
    
    const qrCenterX = (location.topLeftCorner.x + location.bottomRightCorner.x) / 2;
    const qrCenterY = (location.topLeftCorner.y + location.bottomRightCorner.y) / 2;
    const qrWidth = Math.abs(location.bottomRightCorner.x - location.topLeftCorner.x);
    const qrHeight = Math.abs(location.bottomRightCorner.y - location.topLeftCorner.y);
    const qrSize = Math.min(qrWidth, qrHeight);
    
    const deltaX = Math.abs(qrCenterX - centerX);
    const deltaY = Math.abs(qrCenterY - centerY);
    const tolerance = Math.min(frameW, frameH) * 0.1;
    const minSize = Math.min(frameW, frameH) * 0.15;
    
    // Check if well-positioned
    const isWellPositioned = deltaX <= tolerance && deltaY <= tolerance && qrSize >= minSize;
    
    if (isWellPositioned) {
      // QR is well-positioned, proceed with destination input
      stopCamera();
      announce(`QR code scanned successfully. Current location: ${qrData}`, true);
      setTimeout(() => {
        askForDestination();
      }, 1500);
    } else {
      // Continue providing guidance
      setTimeout(() => {
        provideQRGuidance(location);
      }, 2000);
    }
  } else {
    // No location data, assume scan is good enough
    stopCamera();
    announce(`QR code scanned successfully. Current location: ${qrData}`, true);
    setTimeout(() => {
      askForDestination();
    }, 1500);
  }
}

/* ---------------------------
   Destination input workflow
   --------------------------- */
async function askForDestination() {
  if (!SR_AVAILABLE) {
    // Fallback to text input
    const candidates = Object.keys(node_coords).filter(n => n !== currentLocation);
    const candidateList = candidates.map((p,i)=>`${i+1}. ${p}`).join('\n');
    announce("Speech recognition not available. Opening text selection.", false);
    
    const dest = prompt(`Current: ${currentLocation}\nAvailable destinations:\n${candidateList}\n\nType name or number:`);
    if (!dest) {
      announce("No destination selected. Please try again.", false);
      setTimeout(() => askForDestination(), 1000);
      return;
    }
    
    let destination = dest.trim();
    const destNumber = parseInt(destination);
    if (!isNaN(destNumber) && destNumber >= 1 && destNumber <= candidates.length) {
      destination = candidates[destNumber - 1];
    } else {
      const best = findBestLocationMatch(destination, candidates);
      if (best) destination = best;
      else {
        announce("Destination not found. Please try again.", false);
        setTimeout(() => askForDestination(), 1000);
        return;
      }
    }
    
    confirmDestination(destination);
    return;
  }

  let attempts = 0;
  const maxAttempts = 3;
  
  while (attempts < maxAttempts) {
    attempts++;
    
    announce("Please say your destination after the beep.", true);
    await new Promise(r => setTimeout(r, 1000));
    
    const interimBox = document.getElementById('listeningBox');
    interimBox.style.display = 'block';
    interimBox.textContent = "Listening for destination...";
    
    const transcript = await startSpeechRecognition({
      lang: 'en-US',
      interim: true,
      timeout: 15000,
      onInterim: (t) => { interimBox.textContent = "Hearing: " + t; }
    });
    
    interimBox.textContent = '';
    
    if (!transcript) {
      if (attempts < maxAttempts) {
        announce("I didn't hear you clearly. Let's try again.", false);
        continue;
      } else {
        announce("Voice input failed. Using text input instead.", false);
        setTimeout(() => askForDestination(), 500);
        return;
      }
    }
    
    log(`Destination heard: ${transcript}`);
    
    // Find matching destination
    const candidates = Object.keys(node_coords).filter(n => n !== currentLocation);
    const bestMatch = findBestLocationMatch(transcript, candidates);
    
    if (!bestMatch) {
      if (attempts < maxAttempts) {
        announce(`I couldn't find that destination. Available options include: ${candidates.slice(0,3).join(', ')} and others. Please try again.`, false);
        continue;
      } else {
        announce("Destination not found. Using text input instead.", false);
        setTimeout(() => askForDestination(), 500);
        return;
      }
    }
    
    // Confirm the destination
    const confirmed = await confirmDestination(bestMatch);
    if (confirmed) {
      return; // Success!
    } else {
      // User said no, try again
      continue;
    }
  }
  
  // All attempts failed
  announce("Voice input unsuccessful. Please try the text input method.", false);
  setTimeout(() => askForDestination(), 500);
}

async function confirmDestination(destination) {
  if (!SR_AVAILABLE) {
    // Text confirmation
    const confirmed = confirm(`Navigate to: ${destination}?`);
    if (confirmed) {
      finalDestination = destination;
      startNavigation();
      return true;
    } else {
      announce("Destination cancelled. Please select again.", false);
      setTimeout(() => askForDestination(), 1000);
      return false;
    }
  }

  let confirmAttempts = 0;
  const maxConfirmAttempts = 3;
  
  while (confirmAttempts < maxConfirmAttempts) {
    confirmAttempts++;
    
    announce(`Did you mean ${destination}? Say yes or no.`, false);
    await new Promise(r => setTimeout(r, 2000)); // Wait for TTS to finish
    
    const interimBox = document.getElementById('listeningBox');
    interimBox.style.display = 'block';
    interimBox.textContent = "Listening for yes or no...";
    
    const response = await startSpeechRecognition({
      lang: 'en-US',
      interim: false,
      timeout: 10000,
      onInterim: (t) => { interimBox.textContent = "Hearing: " + t; }
    });
    
    interimBox.textContent = '';
    
    if (!response) {
      if (confirmAttempts < maxConfirmAttempts) {
        announce("I didn't hear your response. Please say yes or no clearly.", false);
        continue;
      } else {
        return false; // Failed confirmation
      }
    }
    
    const confirmation = interpretConfirmation(response);
    log(`Confirmation response: ${response} -> ${confirmation}`);
    
    if (confirmation === 'yes') {
      finalDestination = destination;
      announce(`Destination confirmed: ${destination}. Starting navigation.`, true);
      startNavigation();
      return true;
    } else if (confirmation === 'no') {
      announce("Understood. Let's choose a different destination.", false);
      return false; // User wants to pick again
    } else {
      // Ambiguous or unclear response
      if (confirmAttempts < maxConfirmAttempts) {
        announce("Please say clearly 'yes' to confirm or 'no' to choose again.", false);
        continue;
      } else {
        announce("Confirmation unclear. Please start over.", false);
        return false;
      }
    }
  }
  
  return false;
}

function interpretConfirmation(text) {
  if (!text) return 'unknown';
  const s = text.toLowerCase().trim();
  
  const yesPatterns = ['yes', 'yeah', 'yep', 'yup', 'sure', 'correct', 'right', 'ok', 'okay', 'confirm', 'affirmative'];
  const noPatterns = ['no', 'nope', 'nah', 'wrong', 'incorrect', 'cancel', 'stop'];
  
  const hasYes = yesPatterns.some(pattern => s.includes(pattern));
  const hasNo = noPatterns.some(pattern => s.includes(pattern));
  
  if (hasYes && !hasNo) return 'yes';
  if (hasNo && !hasYes) return 'no'; 
  if (hasYes && hasNo) return 'ambiguous';
  return 'unknown';
}

function findBestLocationMatch(input, candidates) {
  const s = input.toLowerCase().trim();
  
  // Exact match
  let match = candidates.find(c => c.toLowerCase() === s);
  if (match) return match;
  
  // Contains match
  match = candidates.find(c => c.toLowerCase().includes(s) || s.includes(c.toLowerCase()));
  if (match) return match;
  
  // Word-based matching
  const inputWords = s.split(/\s+/);
  match = candidates.find(c => {
    const candidateWords = c.toLowerCase().split(/\s+/);
    return inputWords.some(iw => candidateWords.some(cw => 
      iw.includes(cw) || cw.includes(iw) || 
      (iw.length > 2 && cw.length > 2 && (iw.startsWith(cw.slice(0,3)) || cw.startsWith(iw.slice(0,3))))
    ));
  });
  
  return match || null;
}

/* ---------------------------
   Navigation system
   --------------------------- */
function startNavigation() {
  if (!currentLocation || !finalDestination) {
    announce("Cannot start navigation. Missing location information.", true);
    return;
  }
  
  // Calculate route
  const route = dijkstra(graph, currentLocation, finalDestination);
  if (!route.path.length || route.cost === Infinity) {
    announce("No route found to that destination. Please select a different destination.", true);
    setTimeout(() => askForDestination(), 2000);
    return;
  }
  
  isNavigating = true;
  cancelOverlay.style.display = 'block';
  
  announce(`Navigation started to ${finalDestination}. Total distance: ${Math.round(route.cost)} meters. You can tap Cancel Navigation to stop at any time.`, true);
  
  // Start camera for navigation
  setTimeout(async () => {
    const started = await startCamera();
    if (started) {
      announce("Camera ready. Continue scanning QR codes as you move. I will guide you along the route.", false);
      
      // Give initial navigation instruction
      setTimeout(() => {
        provideNavigationGuidance();
      }, 2000);
    }
  }, 1500);
}

function provideNavigationGuidance() {
  if (!isNavigating || !currentLocation || !finalDestination) return;
  
  if (currentLocation === finalDestination) {
    handleDestinationReached();
    return;
  }
  
  // Calculate next step from current location
  const route = dijkstra(graph, currentLocation, finalDestination);
  if (!route.path.length || route.path.length < 2) {
    announce("Route calculation error. Please scan a QR code to update your location.", false);
    return;
  }
  
  const nextLocation = route.path[1]; // Next step in the route
  const distance = graph[currentLocation] && graph[currentLocation][nextLocation] 
    ? graph[currentLocation][nextLocation] 
    : 0;
  
  const direction = getDirection(currentLocation, nextLocation);
  const instruction = `From ${currentLocation}, ${direction} towards ${nextLocation}. Distance: ${distance.toFixed(0)} meters.`;
  
  announce(instruction, false);
  log(`Navigation: ${instruction}`);
}

function getDirection(from, to) {
  if (!node_coords[from] || !node_coords[to]) return "proceed";
  
  const fromCoords = node_coords[from];
  const toCoords = node_coords[to];
  const dx = toCoords[0] - fromCoords[0];
  const dy = toCoords[1] - fromCoords[1];
  
  const angle = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
  
  if (angle >= 315 || angle < 45) return "head east";
  if (angle >= 45 && angle < 135) return "head south";
  if (angle >= 135 && angle < 225) return "head west";
  return "head north";
}

function handleNavigationProgress(newLocation) {
  announce(`Location updated: ${newLocation}`, false);
  log(`Navigation progress: moved to ${newLocation}`);
  
  // Update current location
  currentLocation = newLocation;
  
  // Provide next guidance
  setTimeout(() => {
    provideNavigationGuidance();
  }, 1500);
}

function handleDestinationReached() {
  isNavigating = false;
  cancelOverlay.style.display = 'none';
  stopCamera();
  
  announce(`Congratulations! You have successfully reached your destination: ${finalDestination}. Navigation complete.`, true);
  
  // Vibration pattern for success
  if ('vibrate' in navigator) {
    try {
      navigator.vibrate([200, 100, 200, 100, 300]);
    } catch(e) {}
  }
  
  log(`Navigation completed successfully to ${finalDestination}`);
  
  // Reset for next navigation
  setTimeout(() => {
    currentLocation = finalDestination;
    finalDestination = null;
    announce("Ready for next navigation. Press Start Navigation to begin again.", false);
    overlayText.textContent = "Navigation complete. Ready for next journey.";
  }, 3000);
}

function cancelNavigation() {
  isNavigating = false;
  cancelOverlay.style.display = 'none';
  finalDestination = null;
  
  stopCamera();
  announce("Navigation cancelled.", true);
  
  log("Navigation cancelled by user");
  overlayText.textContent = "Navigation cancelled. Press Start Navigation to begin again.";
}

/* ---------------------------
   Pathfinding (Dijkstra)
   --------------------------- */
function dijkstra(gr, start, end) {
  const pq = new MinHeap();
  pq.push({cost: 0, node: start, path: []});
  const visited = new Set();
  
  while (!pq.empty()) {
    const item = pq.pop();
    const {cost, node, path} = item;
    
    if (visited.has(node)) continue;
    const newPath = path.concat([node]);
    visited.add(node);
    
    if (node === end) return {path: newPath, cost};
    
    const neighbors = gr[node] || {};
    for (const nb in neighbors) {
      if (!visited.has(nb)) {
        pq.push({
          cost: cost + neighbors[nb], 
          node: nb, 
          path: newPath
        });
      }
    }
  }
  
  return {path: [], cost: Infinity};
}

class MinHeap {
  constructor() { this.a = []; }
  push(x) { this.a.push(x); this._siftUp(); }
  pop() { 
    if(this.a.length === 0) return null; 
    const r = this.a[0]; 
    const last = this.a.pop(); 
    if(this.a.length) { this.a[0] = last; this._siftDown(); } 
    return r; 
  }
  empty() { return this.a.length === 0; }
  _siftUp() { 
    let i = this.a.length - 1; 
    while(i > 0) { 
      let p = Math.floor((i-1)/2); 
      if(this.a[p].cost <= this.a[i].cost) break; 
      [this.a[p], this.a[i]] = [this.a[i], this.a[p]]; 
      i = p; 
    } 
  }
  _siftDown() { 
    let i = 0; 
    const n = this.a.length; 
    while(true) { 
      let l = i*2 + 1; 
      let r = i*2 + 2; 
      let smallest = i; 
      if(l < n && this.a[l].cost < this.a[smallest].cost) smallest = l; 
      if(r < n && this.a[r].cost < this.a[smallest].cost) smallest = r; 
      if(smallest === i) break; 
      [this.a[i], this.a[smallest]] = [this.a[smallest], this.a[i]]; 
      i = smallest; 
    } 
  }
}

/* ---------------------------
   Event handlers
   --------------------------- */
startBtn.onclick = async () => {
  if (scannerRunning) {
    announce("Scanner already running.", false);
    return;
  }
  
  userGesturePerformed = true;
  overlayText.textContent = "Starting camera...";
  
  const started = await startCamera();
  if (started) {
    announce("Camera started. Point at any QR code to scan your current location.", true);
    overlayText.textContent = "Point camera at QR code to scan your location";
  }
};

cancelBtn.onclick = () => {
  cancelNavigation();
};

// Keyboard shortcuts
window.addEventListener('keydown', (e) => {
  if (e.key === 's' || e.key === 'S') {
    startBtn.click();
  }
  if (e.key === 'c' || e.key === 'C') {
    if (isNavigating) cancelBtn.click();
  }
  if (e.code === 'Space') {
    e.preventDefault();
    if (isNavigating) {
      cancelBtn.click();
    } else {
      startBtn.click();
    }
  }
});

/* ---------------------------
   Initialization
   --------------------------- */
function onOpenCvReady() { 
  cvReady = true; 
  log("OpenCV ready"); 
}

if (typeof cv !== 'undefined') {
  if (cv && cv.Mat) onOpenCvReady();
  else cv['onRuntimeInitialized'] = onOpenCvReady;
} else {
  setTimeout(() => { 
    if (!cvReady) log("OpenCV not loaded - using basic QR detection"); 
  }, 5000);
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => { 
  if (stream) stream.getTracks().forEach(t => t.stop()); 
  speechSynthesis.cancel(); 
});

// Initial announcement
announce("VI Navigation ready. Press Start Navigation to begin scanning for your location.", false);
log("App initialized. Speech recognition available: " + (SR_AVAILABLE ? 'yes' : 'no'));
</script>
</body>
</html>
