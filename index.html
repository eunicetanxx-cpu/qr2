<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VI-Friendly Indoor Navigation (Enhanced Step-by-Step)</title>
  <style>
    :root{
      --bg:#000; --card:#0b1220; --accent:#ffd54f; --accent-2:#00e676; --text:#fff;
      --muted:#9aa8b2;
      --btn-h:64px; --btn-font:20px;
    }
    html,body{height:100%; margin:0; background:linear-gradient(180deg,#05070a 0%, #0b0f14 100%); color:var(--text); font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; -webkit-font-smoothing:antialiased;}
    
    .app {
      max-width: 980px;
      margin: 12px auto;
      padding: 18px;
      padding-bottom: 200px;
      background: linear-gradient(180deg, #071018 0, #07121a 100%);
      border-radius: 14px;
      box-shadow: 0 8px 36px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.02);
    }
    
    header { display:flex; gap:12px; align-items:center; margin-bottom: 16px; }
    h1 { font-size:24px; margin:0; color:var(--accent); letter-spacing:0.6px; }
    .subtitle { color: var(--muted); font-size:14px; margin-top:4px; }

    /* Mobile-first layout */
    .app-content {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .control-section {
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 12px;
    }
    
    .control-section h2 {
      font-size: 18px;
      margin: 0 0 12px 0;
      color: var(--accent);
    }

    .controls { margin:14px 0; display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .btn { 
      background:var(--accent); 
      color:#000; 
      border:none; 
      padding:12px 18px; 
      border-radius:12px; 
      font-size:var(--btn-font); 
      height:var(--btn-h); 
      min-width:150px; 
      cursor:pointer; 
      box-shadow:0 8px 18px rgba(0,0,0,0.5); 
      flex: 1 1 140px;
    }
    .btn.secondary { background:transparent; color:var(--text); border:2px solid rgba(255,255,255,0.06); }
    .btn.ghost { background:transparent; color:var(--accent); border:2px dashed rgba(255,213,79,0.18); }
    .btn:focus { outline:4px solid rgba(255,213,79,0.25); outline-offset:3px; }
    .select { font-size:18px; padding:12px; border-radius:12px; height:var(--btn-h); background:#07141a; color:var(--text); border:1px solid rgba(255,255,255,0.03); min-width:140px; }
    .btn.green { background:#4caf50; color:#fff; }
    .btn.red { background:#f44336; color:#fff; }
    .btn.yellow { background:#ffeb3b; color:#000; }
    .btn.grey { background:#9e9e9e; color:#fff; }

    .main-controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #071018;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1000;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.6);
    }
    .main-controls .controls-row { display: flex; justify-content: space-between; gap: 12px; }
    .main-controls .controls-row:last-child { justify-content: center; }

    .status-section {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .statusBox { 
      padding:14px; 
      background:linear-gradient(180deg,#071018,#06121a); 
      border-radius:12px; 
      border:1px solid rgba(0,255,136,0.03); 
      min-height:100px; 
      display:flex; 
      flex-direction: column;
      gap:12px;
    }
    
    #overlayText { font-weight:800; font-size:20px; color:var(--text); margin-bottom:6px; }
    #srAnnounce { font-size:17px; color:var(--muted); margin-top:6px; }
    #listeningBox { margin-top:10px; font-size:18px; color:#ffb74d; min-height:22px; }

    .navigation-progress { margin-top:10px; padding:12px; background:#0a1520; border-radius:8px; border:1px solid rgba(0,255,136,0.1); }
    .nav-step { padding:8px 12px; margin:4px 0; border-radius:6px; background:#061217; color:var(--muted); font-size:16px; }
    .nav-step.current { background:var(--accent-2); color:#000; font-weight:bold; }
    .nav-step.completed { background:#2e7d32; color:#fff; }

    .scan-progress { 
      display:flex; 
      flex-direction: column;
      gap:8px;
      margin-top:10px;
    }
    .progress-pill { 
      padding:10px 14px; 
      border-radius:999px; 
      background:#071018; 
      color:var(--muted); 
      font-size:18px; 
      border:1px solid rgba(255,255,255,0.02); 
      text-align:center; 
    }
    .progress-pill.found { background:var(--accent-2); color:#000; font-weight:800; border:2px solid rgba(0,64,0,0.7); }

    #previewWrap { 
      display:flex; 
      justify-content:center; 
      margin-top:14px; 
    }
    #previewCanvas {
      max-width: 100%;
      height: auto;
      background: #000;
      border-radius: 10px;
      border: 2px solid #0b1b2a;
      object-fit: cover;
      display:block;
    }

    .alerts { 
      padding:12px; 
      border-radius:10px; 
      background:#061217; 
      border:1px solid rgba(255,255,255,0.02); 
      min-height:100px; 
      color:var(--muted); 
    }
    .alerts h4 { margin:0 0 6px 0; color:var(--accent); font-size:16px; }
    .alerts ul { margin:0; padding-left:18px; font-size:16px; color:var(--muted); }
    .alerts li { margin-bottom:6px; }

    #log { 
      margin-top:12px; 
      background:#02060a; 
      color:#b8d3de; 
      padding:12px; 
      border-radius:10px; 
      height:160px; 
      overflow:auto; 
      font-size:14px; 
      border:1px solid rgba(255,255,255,0.02); 
    }

    .map-modal { 
      position:fixed; 
      inset:0; 
      display:none; 
      align-items:center; 
      justify-content:center; 
      background:rgba(0,0,0,0.75); 
      z-index:999; 
    }
    .map-modal .box { 
      background:#071018; 
      padding:14px; 
      max-width:900px; 
      width:95%; 
      max-height:85%; 
      overflow:auto; 
      border-radius:10px; 
      border:2px solid rgba(255,255,255,0.02); 
      color:#fff; 
    }
    #mapCanvas { width:100%; height:auto; border-radius:6px; background:#fff; display:block; }

    footer { margin-top:14px; color:var(--muted); font-size:13px; text-align:center; }

    .visually-hidden { position:absolute !important; height:1px; width:1px; overflow:hidden; clip:rect(1px,1px,1px,1px); white-space:nowrap; }
    
    /* Mobile-specific adjustments */
    @media (max-width:760px){
      .app {
        margin: 8px;
        padding: 12px;
        padding-bottom: 180px;
      }
      
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      
      h1 {
        font-size: 22px;
      }
      
      .subtitle {
        font-size: 13px;
      }
      
      .control-section {
        padding: 12px;
      }
      
      .controls {
        gap: 8px;
      }
      
      .btn {
        min-width: 120px;
        font-size: 18px;
        height: 56px;
        flex: 1 1 120px;
      }
      
      .scan-progress {
        flex-direction: column;
      }
      
      .progress-pill {
        min-width: auto;
        font-size: 16px;
      }
      
      #previewCanvas { 
        width:100%; 
        height:260px; 
      }
      
      .statusBox {
        flex-direction: column;
      }
      
      .main-controls {
        padding: 12px;
      }
      
      .main-controls .controls-row {
        flex-wrap: wrap;
      }
      
      .main-controls .btn {
        flex: 1 1 45%;
        min-width: 0;
      }
    }
    
    /* Very small screens */
    @media (max-width: 400px) {
      .app {
        margin: 4px;
        padding: 8px;
        padding-bottom: 160px;
      }
      
      .btn {
        font-size: 16px;
        height: 50px;
        padding: 10px 14px;
      }
      
      #previewCanvas {
        height: 220px;
      }
      
      .main-controls .btn {
        flex: 1 1 100%;
      }
    }
  </style>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
</head>
<body>
  <div class="app" role="application" aria-labelledby="appTitle">
    <header>
      <div>
        <h1 id="appTitle">VI Indoor Navigation</h1>
        <div class="subtitle">Step-by-step QR navigation with voice guidance</div>
      </div>
    </header>

    <div class="app-content">
      <!-- Settings Section -->
      <section class="control-section" aria-labelledby="settingsTitle">
        <h2 id="settingsTitle" class="visually-hidden">Settings</h2>
        <label style="display:flex; align-items:center; gap:8px; color:var(--muted); font-size:16px;">
          <input type="checkbox" id="enableDetect" checked aria-label="Enable object detection"> Enable Object Detection
        </label>
      </section>

      <!-- Status Section -->
      <section class="status-section">
        <div class="statusBox" role="status" aria-live="polite">
          <div id="leftStatus">
            <div id="overlayText">Ready – Start Scan to begin. Voice input will be started automatically when needed.</div>
            <div id="srAnnounce" aria-live="polite" role="log">Status messages will be read aloud.</div>
            <div id="listeningBox" aria-hidden="true"></div>
            
            <div id="navigationProgress" class="navigation-progress" style="display:none;">
              <h4 style="color:var(--accent); margin:0 0 8px 0;">Navigation Steps</h4>
              <div id="navStepsList"></div>
            </div>
            
            <div class="scan-progress" aria-hidden="false">
              <div id="progressRed" class="progress-pill" role="status">Red QR: Not found</div>
              <div id="progressGreen" class="progress-pill" role="status">Green QR: Not found</div>
              <div id="progressBlue" class="progress-pill" role="status">Blue QR: Not found</div>
            </div>
          </div>

          <div id="alertsPanel">
            <div class="alerts" aria-live="polite">
              <h4>Object Alerts</h4>
              <ul id="alertsList"><li>No recent alerts</li></ul>
            </div>
          </div>
        </div>
      </section>

      <!-- Camera Preview Section -->
      <section aria-labelledby="previewTitle">
        <h2 id="previewTitle" class="visually-hidden">Camera Preview</h2>
        <div id="previewWrap">
          <canvas id="previewCanvas" width="800" height="600" aria-label="Camera preview for sighted helper"></canvas>
        </div>
      </section>

      <!-- Log Section -->
      <section aria-labelledby="logTitle">
        <h2 id="logTitle" class="visually-hidden">System Log</h2>
        <div id="log" aria-live="polite" role="log"></div>
      </section>
    </div>

    <!-- Map Modal -->
    <div class="map-modal" id="mapModal" role="dialog" aria-modal="true" aria-labelledby="mapTitle">
      <div class="box">
        <h3 id="mapTitle">Map Preview</h3>
        <canvas id="mapCanvas" width="900" height="600"></canvas>
        <div style="text-align:right; margin-top:8px;">
          <button id="closeMap" class="btn secondary" aria-label="Close map">Close</button>
        </div>
      </div>
    </div>

    <!-- Main Controls -->
    <div class="main-controls" role="region" aria-label="Main controls">
      <div class="controls-row">
        <button id="startBtn" class="btn green" aria-pressed="false" aria-label="Start scanning for QR codes (S)">Start Scan</button>
        <button id="stopBtn" class="btn red" aria-pressed="false" aria-label="Stop scanning (Space)">Stop Scan</button>
        <button id="voiceDestBtn" class="btn yellow" aria-label="Voice destination input (V)">Voice Destination</button>
      </div>
    </div>

    <footer>Built for visually impaired users – spoken prompts, vibration and object alerts help navigation.</footer>
  </div>

<!-- The rest of your JavaScript code remains exactly the same -->
<script>
/* ---------------------------
   DOM Elements & Helpers
   --------------------------- */
const overlayText = document.getElementById('overlayText');
const srAnnounce = document.getElementById('srAnnounce');
const previewCanvas = document.getElementById('previewCanvas');
const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
const canvasDisp = document.createElement('canvas');
const ctxDisp = canvasDisp.getContext('2d', { willReadFrequently: true });
const logEl = document.getElementById('log');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const voiceDestBtn = document.getElementById('voiceDestBtn');
const colorFilterEl = document.getElementById('colorFilter');
const mapBtn = document.getElementById('mapBtn');
const mapModal = document.getElementById('mapModal');
const mapCanvas = document.getElementById('mapCanvas');
const closeMap = document.getElementById('closeMap');
const restartBtn = document.getElementById('restartBtn');
const progressRed = document.getElementById('progressRed');
const progressGreen = document.getElementById('progressGreen');
const progressBlue = document.getElementById('progressBlue');
const enableDetectCheckbox = document.getElementById('enableDetect');
const alertsList = document.getElementById('alertsList');
const navigationProgress = document.getElementById('navigationProgress');
const navStepsList = document.getElementById('navStepsList');

const log = (m) => { 
  console.log(m); 
  const t = new Date().toLocaleTimeString(); 
  logEl.innerText += `[${t}] ${m}\n`; 
  logEl.scrollTop = logEl.scrollHeight; 
};

/* ---------------------------
   Global State Variables
   --------------------------- */
const SCAN_SIZE = 360;
let scanBox = { x: 0, y: 0, size: SCAN_SIZE };
let cvReady = false, animationFrameId = null, stream = null, scannerRunning = false;
let foundResults = new Map(), scanStartTime = Date.now(), currentLocation = null;
let latestDetections = [], actionsTriggered = false;
let cocoModel = null, cocoReady = false;
const DETECTION_INTERVAL_MS = 900, SCORE_THRESHOLD = 0.45, CENTER_TOLERANCE = 0.25;
const DISTANCE_ESTIMATE_SCALE = 1.6; 
let lastDetectTime = 0;
const alertCooldown = 3000; 
const lastAlertAt = {};
const HARMFUL_CLASSES = new Set(['person','chair','couch','bench','dining table','stop sign','tv','suitcase','backpack','bed','toilet']);
let userGesturePerformed = false;
let destinationNode = null;

// Enhanced navigation state
let navigationState = {
  active: false,
  fullPath: [],
  currentStepIndex: 0,
  waitingForQR: false,
  expectedLocation: null,
  waitingForVoice: false,
  skipCount: 0,
  destination: null
};

// Speech Recognition check
let SR_AVAILABLE = false;
try { 
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 
  if (SpeechRecognition) SR_AVAILABLE = true; 
} catch(e){ SR_AVAILABLE=false; }

/* ---------------------------
   Enhanced Text-to-Speech System with Better Timing
   --------------------------- */
const TTS = {
  queue: [], 
  speaking: false,
  currentUtterance: null,
  
  speak(text, interrupt=false) {
    if(!text) return;
    if(interrupt){ 
      this.stop();
      this.queue=[]; 
    }
    this.queue.push(text); 
    this._maybeSpeak();
  },
  
  stop() {
    if (this.currentUtterance) {
      speechSynthesis.cancel();
      this.currentUtterance = null;
    }
    this.speaking = false;
  },
  
  _maybeSpeak() {
    if(this.speaking) return;
    const next = this.queue.shift();
    if(!next) return;
    
    this.speaking = true;
    this.currentUtterance = new SpeechSynthesisUtterance(next); 
    this.currentUtterance.rate = 1.0;
    
    this.currentUtterance.onend = () => { 
      this.speaking = false; 
      this.currentUtterance = null;
      setTimeout(()=>this._maybeSpeak(), 80); 
    };
    
    this.currentUtterance.onerror = () => { 
      this.speaking = false; 
      this.currentUtterance = null;
      setTimeout(()=>this._maybeSpeak(), 80); 
    };
    
    speechSynthesis.speak(this.currentUtterance);
  },
  
  async waitForFinish() {
    return new Promise(resolve => {
      const checkFinished = () => {
        if (!this.speaking && this.queue.length === 0 && !speechSynthesis.speaking) {
          resolve();
        } else {
          setTimeout(checkFinished, 100);
        }
      };
      checkFinished();
    });
  },

  // Force a complete stop and wait for silence
  async forceStopAndWait() {
    this.stop();
    this.queue = [];
    speechSynthesis.cancel();
    
    // Wait for speechSynthesis to actually stop
    return new Promise(resolve => {
      const checkSilence = () => {
        if (!speechSynthesis.speaking) {
          // Add extra delay to ensure complete silence
          setTimeout(resolve, 300);
        } else {
          setTimeout(checkSilence, 100);
        }
      };
      checkSilence();
    });
  }
};

function announce(text, interrupt=false) {
  overlayText.textContent = text;
  srAnnounce.textContent = text;
  TTS.speak(text, interrupt);
  log(`[ANNOUNCE] ${text}`);
}

/* ---------------------------
   QR Code Detection Functions
   --------------------------- */
function createColorMask(imageData, color) {
  const data = imageData.data;
  const w = imageData.width, h = imageData.height;
  const out = new Uint8ClampedArray(data.length);
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i+1], b = data[i+2];
    let hit = false;
    
    if (color === 'red') {
      hit = (r > g + 25 && r > b + 25 && r > 90) || (r > 140 && r > g * 1.3 && r > b * 1.3);
    } else if (color === 'green') {
      hit = (g > r + 25 && g > b + 25 && g > 90) || (g > 140 && g > r * 1.2 && g > b * 1.2);
    } else if (color === 'blue') {
      hit = (b > r + 20 && b > g + 20 && b > 70) || (b > 110 && b > r * 1.05 && b > g * 1.05);
    }
    
    if (hit) {
      out[i] = 255; out[i+1] = 255; out[i+2] = 255; out[i+3] = 255;
    } else {
      out[i] = 0; out[i+1] = 0; out[i+2] = 0; out[i+3] = 255;
    }
  }
  return new ImageData(out, w, h);
}

function extractColorChannel(imageData, channel) {
  const data = imageData.data;
  const out = new Uint8ClampedArray(data.length);
  
  for (let i=0;i<data.length;i+=4){
    const r = data[i], g = data[i+1], b = data[i+2];
    let intensity = 0;
    
    if (channel === 'red') intensity = r;
    else if (channel === 'green') intensity = g;
    else intensity = Math.max(b, Math.floor((b*1.6 + Math.max(r,g)*0.2)));
    
    intensity = Math.min(255, Math.max(0, intensity));
    out[i] = out[i+1] = out[i+2] = intensity;
    out[i+3] = 255;
  }
  return new ImageData(out, imageData.width, imageData.height);
}

function enhanceBlueContrast(imageData) {
  const data = imageData.data;
  const out = new Uint8ClampedArray(data.length);
  
  for (let i=0;i<data.length;i+=4){
    const r = data[i], g = data[i+1], b = data[i+2];
    let intensity = b;
    
    if (b > r && b > g) intensity = Math.min(255, Math.round(b * 1.8));
    else if (b > 70) intensity = Math.min(255, Math.round(b * 1.3));
    else intensity = Math.round((r+g+b)/3 * 0.55);
    
    out[i]=out[i+1]=out[i+2]=intensity; out[i+3]=255;
  }
  return new ImageData(out, imageData.width, imageData.height);
}

function detectWithOpenCV(imageData, color) {
  if (!cvReady) return null;
  try {
    const src = cv.matFromImageData(imageData);
    const rgb = new cv.Mat();
    cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
    const hsv = new cv.Mat();
    cv.cvtColor(rgb, hsv, cv.COLOR_RGB2HSV);

    const mask = new cv.Mat();
    if (color === 'red') {
      const lower1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 80, 40, 0]);
      const upper1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [10, 255, 255, 255]);
      const lower2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [170, 80, 40, 0]);
      const upper2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 255, 255, 255]);
      const m1 = new cv.Mat(), m2 = new cv.Mat();
      cv.inRange(hsv, lower1, upper1, m1);
      cv.inRange(hsv, lower2, upper2, m2);
      cv.add(m1, m2, mask);
      m1.delete(); m2.delete(); lower1.delete(); upper1.delete(); lower2.delete(); upper2.delete();
    } else if (color === 'green') {
      const low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [35, 60, 40, 0]);
      const high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [85, 255, 255, 255]);
      cv.inRange(hsv, low, high, mask);
      low.delete(); high.delete();
    } else {
      const low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [90, 40, 30, 0]);
      const high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [140, 255, 255, 255]);
      cv.inRange(hsv, low, high, mask);
      low.delete(); high.delete();
    }

    const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
    cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
    cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);
    const rgba = new cv.Mat();
    cv.cvtColor(mask, rgba, cv.COLOR_GRAY2RGBA);

    const out = new ImageData(new Uint8ClampedArray(rgba.data), rgba.cols, rgba.rows);

    src.delete(); rgb.delete(); hsv.delete(); mask.delete(); kernel.delete(); rgba.delete();
    return out;
  } catch (e) {
    console.warn("OpenCV detect failed:", e);
    return null;
  }
}

function detect_colored_qr_in_frame_js(imageData, targetColor=null) {
  const COLORS = ['red','green','blue'];
  
  for (const color of COLORS) {
    if (targetColor && color !== targetColor) continue;
    
    try {
      const chImg = extractColorChannel(imageData, color);
      const code = jsQR(chImg.data, chImg.width, chImg.height, { inversionAttempts: 'attemptBoth' });
      if (code && code.data) {
        let boxArea = null;
        if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
          const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
          const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
          boxArea = Math.abs(w*h);
        }
        return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Enhanced-Channel', location: code.location || null, boxArea };
      }
    } catch(e){ console.warn('Enhanced channel decode error', color, e); }

    if (color === 'blue') {
      try {
        const maskImg = createColorMask(imageData, color);
        const code = jsQR(maskImg.data, maskImg.width, maskImg.height, { inversionAttempts: 'attemptBoth' });
        if (code && code.data) {
          let boxArea = null;
          if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
            const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
            const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
            boxArea = Math.abs(w*h);
          }
          return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Color-Mask', location: code.location || null, boxArea };
        }
      } catch(e){ console.warn('Color mask decode error', color, e); }
    }

    if (cvReady) {
      try {
        const cvProcessed = detectWithOpenCV(imageData, color);
        if (cvProcessed) {
          const code = jsQR(cvProcessed.data, cvProcessed.width, cvProcessed.height, { inversionAttempts: 'attemptBoth' });
          if (code && code.data) {
            let boxArea = null;
            if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
              const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
              const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
              boxArea = Math.abs(w*h);
            }
            return { found: true, decoded: code.data.trim(), colorFound: color, method: 'OpenCV-HSV', location: code.location || null, boxArea };
          }
        }
      } catch(e){ console.warn('OpenCV approach failed for', color, e); }
    }

    if (color === 'blue') {
      try {
        const enhanced = enhanceBlueContrast(imageData);
        const code = jsQR(enhanced.data, enhanced.width, enhanced.height, { inversionAttempts: 'attemptBoth' });
        if (code && code.data) {
          let boxArea = null;
          if (code.location && code.location.topLeftCorner && code.location.bottomRightCorner) {
            const w = Math.hypot(code.location.topRightCorner.x - code.location.topLeftCorner.x, code.location.topRightCorner.y - code.location.topLeftCorner.y);
            const h = Math.hypot(code.location.bottomLeftCorner.x - code.location.topLeftCorner.x, code.location.bottomLeftCorner.y - code.location.topLeftCorner.y);
            boxArea = Math.abs(w*h);
          }
          return { found: true, decoded: code.data.trim(), colorFound: color, method: 'Blue-Enhanced', location: code.location || null, boxArea };
        }
      } catch(e){ console.warn('Blue enhancement failed', e); }
    }
  }
  return { found: false };
}

/* ---------------------------
   Progress & UI Updates
   --------------------------- */
function updateProgressDisplay() {
  const colors = ['red', 'green', 'blue'];
  let foundCount = 0;
  
  colors.forEach(color => {
    const el = color === 'red' ? progressRed : color === 'green' ? progressGreen : progressBlue;
    if (foundResults.has(color)) {
      foundCount++;
      el.classList.add('found');
      el.textContent = `${color.toUpperCase()} QR: ${foundResults.get(color).decoded}`;
    } else {
      el.classList.remove('found');
      el.textContent = `${color.charAt(0).toUpperCase() + color.slice(1)} QR: Scanning...`;
    }
  });
  
  if (foundCount > 0 && foundCount < 3) {
    const remaining = 3 - foundCount;
    announce(`${foundCount} of 3 QR codes found. ${remaining} remaining.`, false);
  }
  
  console.log(`Progress: ${foundCount}/3 QR codes found`);
}

function updateAlertsList(dets) {
  alertsList.innerHTML = '';
  for (const d of dets) {
    const li = document.createElement('li');
    li.textContent = `${d.class} ${(d.score*100).toFixed(0)}%`;
    alertsList.appendChild(li);
  }
  if (dets.length === 0) {
    const li = document.createElement('li');
    li.textContent = 'No recent alerts';
    alertsList.appendChild(li);
  }
}

/* ---------------------------
   Vibration Helpers
   --------------------------- */
let lastVibrateAt = 0;
function vibrateProximityFromRatio(ratio) {
  if (!('vibrate' in navigator)) return;
  const now = Date.now();
  if (now - lastVibrateAt < 160) return;
  lastVibrateAt = now;
  const intensity = Math.min(1, Math.max(0, (ratio - 0.02) / 0.6));
  const dur = Math.round(40 + intensity * 280);
  const pattern = [dur, 40];
  try { navigator.vibrate(pattern); } catch(e){}
}

function vibrateArrival() {
  if (!('vibrate' in navigator)) return;
  try { navigator.vibrate([80,40,80,40,120]); } catch(e){}
}

/* ---------------------------
   Camera Functions
   --------------------------- */
async function startCamera() {
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }, 
      audio: false
    });
    
    const video = document.createElement('video');
    video.autoplay = true; 
    video.playsInline = true; 
    video.muted = true;
    video.srcObject = stream;
    await video.play();

    canvasDisp.width = video.videoWidth || 1280;
    canvasDisp.height = video.videoHeight || 720;
    previewCanvas.width = Math.min(1280, canvasDisp.width);
    previewCanvas.height = Math.min(720, canvasDisp.height);
    
    scanBox.x = Math.floor((canvasDisp.width - scanBox.size) / 2);
    scanBox.y = Math.floor((canvasDisp.height - scanBox.size) / 2);
    
    return video;
  } catch (err) {
    console.error("Camera error:", err);
    announce("Camera access failed. Please check permissions and try again.");
    return null;
  }
}

function stopCamera() {
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
    stream = null;
  }
}

/* ---------------------------
   Object Detection with COCO-SSD
   --------------------------- */
async function loadCocoModel() {
  try {
    cocoModel = await cocoSsd.load();
    cocoReady = true;
    log("COCO-SSD model loaded");
  } catch (err) {
    console.error("COCO-SSD load error:", err);
    cocoReady = false;
  }
}

async function detectObjects(imageData) {
  if (!cocoReady || !enableDetectCheckbox.checked) return [];
  if (Date.now() - lastDetectTime < DETECTION_INTERVAL_MS) return [];
  lastDetectTime = Date.now();
  
  try {
    const detections = await cocoModel.detect(previewCanvas);
    const filtered = detections.filter(d => d.score >= SCORE_THRESHOLD);
    const harmful = filtered.filter(d => HARMFUL_CLASSES.has(d.class));
    
    if (harmful.length > 0) {
      const now = Date.now();
      const alertKey = harmful.map(d => d.class).sort().join(',');
      if (!lastAlertAt[alertKey] || now - lastAlertAt[alertKey] > alertCooldown) {
        lastAlertAt[alertKey] = now;
        const alertMsg = `Alert: ${harmful.map(d => d.class).join(', ')} nearby`;
        announce(alertMsg, false);
      }
    }
    
    latestDetections = harmful;
    updateAlertsList(harmful);
    return filtered;
  } catch (err) {
    console.error("Detection error:", err);
    return [];
  }
}

/* ---------------------------
   Navigation System
   --------------------------- */
// Enhanced navigation system with step-by-step guidance
function parseQRData(data) {
  try {
    const parts = data.split('|');
    if (parts.length < 3) return null;
    
    return {
      nodeId: parts[0].trim(),
      location: parts[1].trim(),
      neighbors: parts[2].split(',').map(n => n.trim())
    };
  } catch (e) {
    console.error("QR parse error:", e);
    return null;
  }
}

// Simple pathfinding (BFS)
function findPath(startNode, endNode, graph) {
  const queue = [[startNode]];
  const visited = new Set([startNode]);
  
  while (queue.length > 0) {
    const path = queue.shift();
    const node = path[path.length - 1];
    
    if (node === endNode) return path;
    
    const neighbors = graph[node] || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push([...path, neighbor]);
      }
    }
  }
  
  return null; // No path found
}

// Build navigation graph from found QR codes
function buildNavigationGraph() {
  const graph = {};
  
  foundResults.forEach((result, color) => {
    const data = parseQRData(result.decoded);
    if (data) {
      graph[data.nodeId] = data.neighbors;
    }
  });
  
  return graph;
}

// Set destination and start navigation
async function setDestination(destination) {
  if (!destination) return;
  
  // Build graph from found QR codes
  const graph = buildNavigationGraph();
  
  if (Object.keys(graph).length === 0) {
    announce("No navigation data available. Please scan more QR codes first.");
    return;
  }
  
  // Find the current location (most recently scanned QR)
  let currentLoc = null;
  let latestTime = 0;
  
  foundResults.forEach((result, color) => {
    const data = parseQRData(result.decoded);
    if (data && result.timestamp > latestTime) {
      currentLoc = data.nodeId;
      latestTime = result.timestamp;
    }
  });
  
  if (!currentLoc) {
    announce("Current location not found. Please scan a QR code first.");
    return;
  }
  
  // Find path to destination
  const path = findPath(currentLoc, destination, graph);
  
  if (!path) {
    announce(`No path found from ${currentLoc} to ${destination}`);
    return;
  }
  
  // Set up navigation state
  navigationState.active = true;
  navigationState.fullPath = path;
  navigationState.currentStepIndex = 0;
  navigationState.destination = destination;
  navigationState.waitingForQR = true;
  navigationState.expectedLocation = path[1]; // Next location after current
  
  // Show navigation progress
  navigationProgress.style.display = 'block';
  updateNavigationSteps();
  
  announce(`Navigation started. From ${currentLoc} to ${destination}. Follow the voice instructions.`);
  
  // Start guiding to next step
  guideToNextStep();
}

// Update the navigation steps display
function updateNavigationSteps() {
  navStepsList.innerHTML = '';
  
  navigationState.fullPath.forEach((step, index) => {
    const stepEl = document.createElement('div');
    stepEl.className = 'nav-step';
    
    if (index === navigationState.currentStepIndex) {
      stepEl.classList.add('current');
      stepEl.textContent = `Current: ${step}`;
    } else if (index < navigationState.currentStepIndex) {
      stepEl.classList.add('completed');
      stepEl.textContent = `Completed: ${step}`;
    } else {
      stepEl.textContent = `Next: ${step}`;
    }
    
    navStepsList.appendChild(stepEl);
  });
}

// Guide user to the next step in navigation
async function guideToNextStep() {
  if (!navigationState.active) return;
  
  const currentStep = navigationState.fullPath[navigationState.currentStepIndex];
  const nextStep = navigationState.fullPath[navigationState.currentStepIndex + 1];
  
  if (!nextStep) {
    // Destination reached
    announce(`You have arrived at ${navigationState.destination}. Navigation complete.`);
    navigationState.active = false;
    navigationProgress.style.display = 'none';
    vibrateArrival();
    return;
  }
  
  navigationState.waitingForQR = true;
  navigationState.expectedLocation = nextStep;
  
  announce(`Proceed from ${currentStep} to ${nextStep}. Scan the QR code at ${nextStep} when you arrive.`);
  updateNavigationSteps();
}

// Process QR code during navigation
function processQRDuringNavigation(qrData, color) {
  if (!navigationState.active || !navigationState.waitingForQR) return false;
  
  const data = parseQRData(qrData);
  if (!data) return false;
  
  // Check if this is the expected location
  if (data.nodeId === navigationState.expectedLocation) {
    // Advance to next step
    navigationState.currentStepIndex++;
    navigationState.waitingForQR = false;
    navigationState.skipCount = 0;
    
    updateNavigationSteps();
    
    // Check if we've reached the destination
    if (navigationState.currentStepIndex >= navigationState.fullPath.length - 1) {
      announce(`You have arrived at ${navigationState.destination}. Navigation complete.`);
      navigationState.active = false;
      navigationProgress.style.display = 'none';
      vibrateArrival();
    } else {
      // Continue to next step after a delay
      setTimeout(() => guideToNextStep(), 2000);
    }
    
    return true;
  }
  
  return false;
}

/* ---------------------------
   Voice Recognition for Destination Input
   --------------------------- */
function startVoiceDestination() {
  if (!SR_AVAILABLE) {
    announce("Speech recognition not available in this browser.");
    return;
  }
  
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
  
  recognition.onstart = () => {
    announce("Listening for destination...");
    document.getElementById('listeningBox').textContent = "Listening...";
  };
  
  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript.trim();
    document.getElementById('listeningBox').textContent = `Heard: ${transcript}`;
    
    // Simple destination mapping
    const destMap = {
      'kitchen': 'K',
      'living room': 'LR',
      'bedroom': 'BR',
      'bathroom': 'BT',
      'entrance': 'E',
      'exit': 'E',
      'office': 'O',
      'dining room': 'DR'
    };
    
    let destination = null;
    for (const [key, value] of Object.entries(destMap)) {
      if (transcript.toLowerCase().includes(key)) {
        destination = value;
        break;
      }
    }
    
    if (destination) {
      announce(`Destination set to: ${destination}`);
      setDestination(destination);
    } else {
      announce(`Destination "${transcript}" not recognized. Please try again.`);
    }
  };
  
  recognition.onerror = (event) => {
    console.error("Speech recognition error:", event.error);
    document.getElementById('listeningBox').textContent = `Error: ${event.error}`;
    announce("Speech recognition error. Please try again.");
  };
  
  recognition.onend = () => {
    document.getElementById('listeningBox').textContent = "";
  };
  
  recognition.start();
}

/* ---------------------------
   Main Scanner Loop
   --------------------------- */
async function scannerLoop(video) {
  if (!scannerRunning) return;
  
  try {
    ctxDisp.drawImage(video, 0, 0, canvasDisp.width, canvasDisp.height);
    const imageData = ctxDisp.getImageData(scanBox.x, scanBox.y, scanBox.size, scanBox.size);
    
    // QR Detection
    const result = detect_colored_qr_in_frame_js(imageData);
    
    if (result.found) {
      const now = Date.now();
      const existing = foundResults.get(result.colorFound);
      
      if (!existing || existing.decoded !== result.decoded || now - existing.timestamp > 5000) {
        foundResults.set(result.colorFound, {
          decoded: result.decoded,
          timestamp: now,
          location: result.location,
          boxArea: result.boxArea
        });
        
        log(`QR ${result.colorFound}: ${result.decoded} (${result.method})`);
        
        // Check if this QR is part of navigation
        if (!processQRDuringNavigation(result.decoded, result.colorFound)) {
          // Not part of navigation, just announce the finding
          announce(`${result.colorFound} QR code found: ${result.decoded}`);
        }
        
        updateProgressDisplay();
        
        if (foundResults.size === 3) {
          announce("All three QR codes found! Navigation data is ready.");
          vibrateArrival();
        }
      }
    }
    
    // Object Detection
    if (enableDetectCheckbox.checked) {
      await detectObjects(imageData);
    }
    
    // Draw preview with annotations
    previewCtx.drawImage(canvasDisp, 0, 0, previewCanvas.width, previewCanvas.height);
    
    // Draw scan box
    const scaleX = previewCanvas.width / canvasDisp.width;
    const scaleY = previewCanvas.height / canvasDisp.height;
    previewCtx.strokeStyle = '#ffd54f';
    previewCtx.lineWidth = 3;
    previewCtx.strokeRect(
      scanBox.x * scaleX, 
      scanBox.y * scaleY, 
      scanBox.size * scaleX, 
      scanBox.size * scaleY
    );
    
    // Draw found QR indicators
    foundResults.forEach((result, color) => {
      if (result.location) {
        const centerX = (scanBox.x + result.location.topLeftCorner.x) * scaleX;
        const centerY = (scanBox.y + result.location.topLeftCorner.y) * scaleY;
        
        previewCtx.fillStyle = color;
        previewCtx.beginPath();
        previewCtx.arc(centerX, centerY, 10, 0, Math.PI * 2);
        previewCtx.fill();
        
        previewCtx.fillStyle = '#fff';
        previewCtx.font = '14px Arial';
        previewCtx.fillText(color.charAt(0).toUpperCase(), centerX-4, centerY+4);
      }
    });
    
    // Draw object detection results
    if (latestDetections.length > 0) {
      latestDetections.forEach(det => {
        const [x, y, width, height] = det.bbox;
        previewCtx.strokeStyle = '#ff3d00';
        previewCtx.lineWidth = 2;
        previewCtx.strokeRect(x, y, width, height);
        previewCtx.fillStyle = '#ff3d00';
        previewCtx.font = '14px Arial';
        previewCtx.fillText(`${det.class} (${Math.round(det.score*100)}%)`, x, y-5);
      });
    }
    
  } catch (err) {
    console.error("Scanner loop error:", err);
  }
  
  if (scannerRunning) {
    animationFrameId = requestAnimationFrame(() => scannerLoop(video));
  }
}

/* ---------------------------
   Start/Stop Scanning
   --------------------------- */
async function startScanning() {
  if (scannerRunning) return;
  
  const video = await startCamera();
  if (!video) return;
  
  scannerRunning = true;
  startBtn.setAttribute('aria-pressed', 'true');
  stopBtn.setAttribute('aria-pressed', 'false');
  
  announce("Scanning started. Point camera at QR codes.");
  
  // Start the scanner loop
  animationFrameId = requestAnimationFrame(() => scannerLoop(video));
}

function stopScanning() {
  scannerRunning = false;
  startBtn.setAttribute('aria-pressed', 'false');
  stopBtn.setAttribute('aria-pressed', 'true');
  
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  
  stopCamera();
  announce("Scanning stopped.");
}

/* ---------------------------
   Keyboard Shortcuts
   --------------------------- */
document.addEventListener('keydown', (e) => {
  if (e.key === 's' || e.key === 'S') {
    e.preventDefault();
    if (!scannerRunning) startScanning();
  } else if (e.key === ' ') {
    e.preventDefault();
    if (scannerRunning) stopScanning();
  } else if (e.key === 'v' || e.key === 'V') {
    e.preventDefault();
    startVoiceDestination();
  }
});

/* ---------------------------
   Event Listeners
   --------------------------- */
startBtn.addEventListener('click', startScanning);
stopBtn.addEventListener('click', stopScanning);
voiceDestBtn.addEventListener('click', startVoiceDestination);

closeMap.addEventListener('click', () => {
  mapModal.style.display = 'none';
});

/* ---------------------------
   Initialization
   --------------------------- */
async function init() {
  log("Initializing VI Navigation System...");
  
  // Check for OpenCV
  if (typeof cv !== 'undefined') {
    cv['onRuntimeInitialized'] = () => {
      cvReady = true;
      log("OpenCV ready");
    };
  } else {
    log("OpenCV not loaded");
  }
  
  // Load COCO-SSD model
  await loadCocoModel();
  
  // Initial announcement
  setTimeout(() => {
    announce("VI Indoor Navigation System ready. Press Start Scan or S key to begin.");
  }, 1000);
  
  log("System ready");
}

// Start initialization when page loads
window.addEventListener('load', init);
</script>
</body>
</html>
